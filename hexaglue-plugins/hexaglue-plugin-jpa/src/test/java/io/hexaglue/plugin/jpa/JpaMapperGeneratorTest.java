/*
 * This Source Code Form is part of the HexaGlue project.
 * Copyright (c) 2026 Scalastic
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 *
 * Commercial licensing options are available for organizations wishing
 * to use HexaGlue under terms different from the MPL 2.0.
 * Contact: info@hexaglue.io
 */

package io.hexaglue.plugin.jpa;

import static io.hexaglue.plugin.jpa.TestFixtures.*;
import static org.assertj.core.api.Assertions.assertThat;

import io.hexaglue.spi.ir.*;
import java.util.List;
import java.util.Optional;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

@DisplayName("JpaMapperGenerator")
class JpaMapperGeneratorTest {

    private static final String INFRA_PKG = "com.example.infrastructure.persistence";
    private static final String DOMAIN_PKG = "com.example.domain";

    private JpaMapperGenerator generator;
    private JpaConfig config;

    @BeforeEach
    void setUp() {
        config = JpaConfig.defaults();
        generator = new JpaMapperGenerator(INFRA_PKG, DOMAIN_PKG, config);
    }

    @Nested
    @DisplayName("generateMapper()")
    class GenerateMapperTests {

        @Test
        @DisplayName("should generate package declaration")
        void shouldGeneratePackageDeclaration() {
            DomainType type = simpleAggregateRoot("Order", DOMAIN_PKG);

            String code = generator.generateMapper(type, List.of());

            assertThat(code).startsWith("package " + INFRA_PKG + ";");
        }

        @Test
        @DisplayName("should generate @Mapper annotation with Spring component model")
        void shouldGenerateMapperAnnotationWithSpringComponentModel() {
            DomainType type = simpleAggregateRoot("Order", DOMAIN_PKG);

            String code = generator.generateMapper(type, List.of());

            assertThat(code).contains("@Mapper(componentModel = MappingConstants.ComponentModel.SPRING)");
        }

        @Test
        @DisplayName("should generate interface with Mapper suffix")
        void shouldGenerateInterfaceWithMapperSuffix() {
            DomainType type = simpleAggregateRoot("Order", DOMAIN_PKG);

            String code = generator.generateMapper(type, List.of());

            assertThat(code).contains("public interface OrderMapper {");
        }

        @Test
        @DisplayName("should import MapStruct annotations")
        void shouldImportMapStructAnnotations() {
            DomainType type = simpleAggregateRoot("Order", DOMAIN_PKG);

            String code = generator.generateMapper(type, List.of());

            assertThat(code).contains("import org.mapstruct.Mapper;");
            assertThat(code).contains("import org.mapstruct.Mapping;");
            assertThat(code).contains("import org.mapstruct.MappingConstants;");
        }

        @Test
        @DisplayName("should import domain class")
        void shouldImportDomainClass() {
            DomainType type = simpleAggregateRoot("Order", DOMAIN_PKG);

            String code = generator.generateMapper(type, List.of());

            assertThat(code).contains("import " + DOMAIN_PKG + ".Order;");
        }

        @Test
        @DisplayName("should generate javadoc")
        void shouldGenerateJavadoc() {
            DomainType type = simpleAggregateRoot("Order", DOMAIN_PKG);

            String code = generator.generateMapper(type, List.of());

            assertThat(code).contains("MapStruct mapper for {@link Order} ↔ {@link OrderEntity}");
            assertThat(code).contains("Generated by HexaGlue JPA Plugin");
        }
    }

    @Nested
    @DisplayName("toEntity() method")
    class ToEntityMethodTests {

        @Test
        @DisplayName("should generate toEntity method")
        void shouldGenerateToEntityMethod() {
            DomainType type = simpleAggregateRoot("Order", DOMAIN_PKG);

            String code = generator.generateMapper(type, List.of());

            assertThat(code).contains("OrderEntity toEntity(Order domain);");
        }

        @Test
        @DisplayName("should generate @Mapping for wrapped identity unwrapping")
        void shouldGenerateMappingForWrappedIdentityUnwrapping() {
            DomainType type = simpleAggregateRoot("Order", DOMAIN_PKG);

            String code = generator.generateMapper(type, List.of());

            assertThat(code).contains("@Mapping(source = \"id.value\", target = \"id\")");
        }

        @Test
        @DisplayName("should NOT generate @Mapping for raw identity")
        void shouldNotGenerateMappingForRawIdentity() {
            DomainType type = simpleEntity("Order", DOMAIN_PKG);

            String code = generator.generateMapper(type, List.of());

            // No mapping needed for raw Long/UUID id
            long idMappingCount = code.lines()
                    .filter(line -> line.contains("@Mapping") && line.contains("id"))
                    .count();
            assertThat(idMappingCount).isZero();
        }

        @Test
        @DisplayName("should generate toEntity javadoc")
        void shouldGenerateToEntityJavadoc() {
            DomainType type = simpleAggregateRoot("Order", DOMAIN_PKG);

            String code = generator.generateMapper(type, List.of());

            assertThat(code).contains("Converts domain object to JPA entity");
            assertThat(code).contains("@param domain the domain object");
            assertThat(code).contains("@return the JPA entity");
        }
    }

    @Nested
    @DisplayName("toDomain() method")
    class ToDomainMethodTests {

        @Test
        @DisplayName("should generate toDomain method")
        void shouldGenerateToDomainMethod() {
            DomainType type = simpleAggregateRoot("Order", DOMAIN_PKG);

            String code = generator.generateMapper(type, List.of());

            assertThat(code).contains("Order toDomain(OrderEntity entity);");
        }

        @Test
        @DisplayName("should generate @Mapping expression for wrapped identity wrapping")
        void shouldGenerateMappingExpressionForWrappedIdentityWrapping() {
            DomainType type = simpleAggregateRoot("Order", DOMAIN_PKG);

            String code = generator.generateMapper(type, List.of());

            assertThat(code).contains("@Mapping(target = \"id\", expression = \"java(new OrderId(entity.getId()))\")");
        }

        @Test
        @DisplayName("should generate toDomain javadoc")
        void shouldGenerateToDomainJavadoc() {
            DomainType type = simpleAggregateRoot("Order", DOMAIN_PKG);

            String code = generator.generateMapper(type, List.of());

            assertThat(code).contains("Converts JPA entity to domain object");
            assertThat(code).contains("@param entity the JPA entity");
            assertThat(code).contains("@return the domain object");
        }
    }

    @Nested
    @DisplayName("List mapping methods")
    class ListMappingMethodsTests {

        @Test
        @DisplayName("should generate toEntityList method")
        void shouldGenerateToEntityListMethod() {
            DomainType type = simpleAggregateRoot("Order", DOMAIN_PKG);

            String code = generator.generateMapper(type, List.of());

            assertThat(code).contains("java.util.List<OrderEntity> toEntityList(java.util.List<Order> domains);");
        }

        @Test
        @DisplayName("should generate toDomainList method")
        void shouldGenerateToDomainListMethod() {
            DomainType type = simpleAggregateRoot("Order", DOMAIN_PKG);

            String code = generator.generateMapper(type, List.of());

            assertThat(code).contains("java.util.List<Order> toDomainList(java.util.List<OrderEntity> entities);");
        }

        @Test
        @DisplayName("should generate list mapping javadocs")
        void shouldGenerateListMappingJavadocs() {
            DomainType type = simpleAggregateRoot("Order", DOMAIN_PKG);

            String code = generator.generateMapper(type, List.of());

            assertThat(code).contains("Converts a list of domain objects to entities");
            assertThat(code).contains("Converts a list of entities to domain objects");
        }
    }

    @Nested
    @DisplayName("Related mappers (uses clause)")
    class RelatedMappersTests {

        @Test
        @DisplayName("should include uses clause for embedded value object mappers")
        void shouldIncludeUsesClauseForEmbeddedVOMappers() {
            DomainType type = aggregateRootWithRelations(
                    "Order", DOMAIN_PKG, List.of(embeddedRelation("address", DOMAIN_PKG + ".Address")));

            DomainType addressVO = simpleValueObject("Address", DOMAIN_PKG);

            String code = generator.generateMapper(type, List.of(addressVO));

            assertThat(code).contains("uses = {AddressMapper.class}");
        }

        @Test
        @DisplayName("should include multiple mappers in uses clause")
        void shouldIncludeMultipleMappersInUsesClause() {
            DomainType type = aggregateRootWithRelations(
                    "Order",
                    DOMAIN_PKG,
                    List.of(
                            embeddedRelation("address", DOMAIN_PKG + ".Address"),
                            elementCollectionRelation("tags", DOMAIN_PKG + ".Tag")));

            DomainType addressVO = simpleValueObject("Address", DOMAIN_PKG);
            DomainType tagVO = simpleValueObject("Tag", DOMAIN_PKG);

            String code = generator.generateMapper(type, List.of(addressVO, tagVO));

            assertThat(code).contains("uses = {");
            assertThat(code).contains("AddressMapper.class");
            assertThat(code).contains("TagMapper.class");
        }

        @Test
        @DisplayName("should NOT include uses clause when no embedded VOs")
        void shouldNotIncludeUsesClauseWhenNoEmbeddedVOs() {
            DomainType type = simpleAggregateRoot("Order", DOMAIN_PKG);

            String code = generator.generateMapper(type, List.of());

            assertThat(code).doesNotContain("uses = ");
        }
    }

    @Nested
    @DisplayName("generateValueObjectMapper()")
    class GenerateValueObjectMapperTests {

        @Test
        @DisplayName("should generate @Mapper annotation")
        void shouldGenerateMapperAnnotation() {
            DomainType vo = simpleValueObject("Address", DOMAIN_PKG);

            String code = generator.generateValueObjectMapper(vo);

            assertThat(code).contains("@Mapper(componentModel = MappingConstants.ComponentModel.SPRING)");
        }

        @Test
        @DisplayName("should generate toEmbeddable method")
        void shouldGenerateToEmbeddableMethod() {
            DomainType vo = simpleValueObject("Address", DOMAIN_PKG);

            String code = generator.generateValueObjectMapper(vo);

            assertThat(code).contains("AddressEmbeddable toEmbeddable(Address domain);");
        }

        @Test
        @DisplayName("should generate toDomain method")
        void shouldGenerateToDomainMethodForVO() {
            DomainType vo = simpleValueObject("Address", DOMAIN_PKG);

            String code = generator.generateValueObjectMapper(vo);

            assertThat(code).contains("Address toDomain(AddressEmbeddable entity);");
        }

        @Test
        @DisplayName("should generate toEmbeddableList method")
        void shouldGenerateToEmbeddableListMethod() {
            DomainType vo = simpleValueObject("Address", DOMAIN_PKG);

            String code = generator.generateValueObjectMapper(vo);

            assertThat(code)
                    .contains("java.util.List<AddressEmbeddable> toEmbeddableList(java.util.List<Address> domains);");
        }

        @Test
        @DisplayName("should generate toDomainList method for VO")
        void shouldGenerateToDomainListMethodForVO() {
            DomainType vo = simpleValueObject("Address", DOMAIN_PKG);

            String code = generator.generateValueObjectMapper(vo);

            assertThat(code)
                    .contains("java.util.List<Address> toDomainList(java.util.List<AddressEmbeddable> entities);");
        }

        @Test
        @DisplayName("should generate javadoc for VO mapper")
        void shouldGenerateJavadocForVOMapper() {
            DomainType vo = simpleValueObject("Address", DOMAIN_PKG);

            String code = generator.generateValueObjectMapper(vo);

            assertThat(code).contains("MapStruct mapper for {@link Address} ↔ {@link AddressEmbeddable}");
        }

        @Test
        @DisplayName("should generate toEmbeddable javadoc")
        void shouldGenerateToEmbeddableJavadoc() {
            DomainType vo = simpleValueObject("Address", DOMAIN_PKG);

            String code = generator.generateValueObjectMapper(vo);

            assertThat(code).contains("Converts domain value object to JPA embeddable");
        }

        @Test
        @DisplayName("should generate toDomain javadoc for VO")
        void shouldGenerateToDomainJavadocForVO() {
            DomainType vo = simpleValueObject("Address", DOMAIN_PKG);

            String code = generator.generateValueObjectMapper(vo);

            assertThat(code).contains("Converts JPA embeddable to domain value object");
        }
    }

    @Nested
    @DisplayName("Custom suffix configuration")
    class CustomSuffixTests {

        @Test
        @DisplayName("should use custom mapper suffix")
        void shouldUseCustomMapperSuffix() {
            JpaConfig customConfig = new JpaConfig(
                    "Entity", "JpaRepository", "Adapter", "Converter", "", false, false, true, true, true);
            JpaMapperGenerator gen = new JpaMapperGenerator(INFRA_PKG, DOMAIN_PKG, customConfig);
            DomainType type = simpleAggregateRoot("Order", DOMAIN_PKG);

            String code = gen.generateMapper(type, List.of());

            assertThat(code).contains("public interface OrderConverter {");
        }

        @Test
        @DisplayName("should use custom entity suffix in methods")
        void shouldUseCustomEntitySuffixInMethods() {
            JpaConfig customConfig =
                    new JpaConfig("Jpa", "JpaRepository", "Adapter", "Mapper", "", false, false, true, true, true);
            JpaMapperGenerator gen = new JpaMapperGenerator(INFRA_PKG, DOMAIN_PKG, customConfig);
            DomainType type = simpleAggregateRoot("Order", DOMAIN_PKG);

            String code = gen.generateMapper(type, List.of());

            assertThat(code).contains("OrderJpa toEntity(Order domain);");
            assertThat(code).contains("Order toDomain(OrderJpa entity);");
        }
    }

    @Nested
    @DisplayName("Identity field name handling")
    class IdentityFieldNameTests {

        @Test
        @DisplayName("should handle custom identity field names")
        void shouldHandleCustomIdentityFieldNames() {
            Identity customId = new Identity(
                    "orderId",
                    TypeRef.of(DOMAIN_PKG + ".OrderId"),
                    TypeRef.of("java.util.UUID"),
                    IdentityStrategy.ASSIGNED,
                    IdentityWrapperKind.RECORD);

            DomainType type = new DomainType(
                    DOMAIN_PKG + ".Order",
                    "Order",
                    DOMAIN_PKG,
                    DomainKind.AGGREGATE_ROOT,
                    ConfidenceLevel.HIGH,
                    JavaConstruct.CLASS,
                    Optional.of(customId),
                    List.of(identityProperty("orderId", TypeRef.of(DOMAIN_PKG + ".OrderId"))),
                    List.of(),
                    List.of(),
                    SourceRef.unknown());

            String code = generator.generateMapper(type, List.of());

            assertThat(code).contains("@Mapping(source = \"orderId.value\", target = \"orderId\")");
            assertThat(code)
                    .contains(
                            "@Mapping(target = \"orderId\", expression = \"java(new OrderId(entity.getOrderId()))\")");
        }
    }
}
