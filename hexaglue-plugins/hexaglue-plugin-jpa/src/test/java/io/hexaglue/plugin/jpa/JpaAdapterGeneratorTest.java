package io.hexaglue.plugin.jpa;

import static io.hexaglue.plugin.jpa.TestFixtures.*;
import static org.assertj.core.api.Assertions.assertThat;

import io.hexaglue.spi.ir.*;
import java.util.List;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

@DisplayName("JpaAdapterGenerator")
class JpaAdapterGeneratorTest {

    private static final String INFRA_PKG = "com.example.infrastructure.persistence";
    private static final String DOMAIN_PKG = "com.example.domain";

    private JpaAdapterGenerator generator;
    private JpaConfig config;

    @BeforeEach
    void setUp() {
        config = JpaConfig.defaults();
        generator = new JpaAdapterGenerator(INFRA_PKG, config);
    }

    @Nested
    @DisplayName("generateAdapter()")
    class GenerateAdapterTests {

        @Test
        @DisplayName("should generate package declaration")
        void shouldGeneratePackageDeclaration() {
            DomainType type = simpleAggregateRoot("Order", DOMAIN_PKG);
            Port port = simpleRepository("Order", DOMAIN_PKG, DOMAIN_PKG + ".OrderId");

            String code = generator.generateAdapter(port, type);

            assertThat(code).startsWith("package " + INFRA_PKG + ";");
        }

        @Test
        @DisplayName("should generate @Component annotation")
        void shouldGenerateComponentAnnotation() {
            DomainType type = simpleAggregateRoot("Order", DOMAIN_PKG);
            Port port = simpleRepository("Order", DOMAIN_PKG, DOMAIN_PKG + ".OrderId");

            String code = generator.generateAdapter(port, type);

            assertThat(code).contains("@Component");
        }

        @Test
        @DisplayName("should generate @Transactional annotation")
        void shouldGenerateTransactionalAnnotation() {
            DomainType type = simpleAggregateRoot("Order", DOMAIN_PKG);
            Port port = simpleRepository("Order", DOMAIN_PKG, DOMAIN_PKG + ".OrderId");

            String code = generator.generateAdapter(port, type);

            assertThat(code).contains("@Transactional");
        }

        @Test
        @DisplayName("should implement port interface")
        void shouldImplementPortInterface() {
            DomainType type = simpleAggregateRoot("Order", DOMAIN_PKG);
            Port port = simpleRepository("Order", DOMAIN_PKG, DOMAIN_PKG + ".OrderId");

            String code = generator.generateAdapter(port, type);

            assertThat(code).contains("public class OrderAdapter implements OrderRepository {");
        }

        @Test
        @DisplayName("should generate constructor with JPA repository and mapper")
        void shouldGenerateConstructorWithDependencies() {
            DomainType type = simpleAggregateRoot("Order", DOMAIN_PKG);
            Port port = simpleRepository("Order", DOMAIN_PKG, DOMAIN_PKG + ".OrderId");

            String code = generator.generateAdapter(port, type);

            assertThat(code).contains("private final OrderJpaRepository orderJpaRepository;");
            assertThat(code).contains("private final OrderMapper orderMapper;");
            assertThat(code)
                    .contains("public OrderAdapter(OrderJpaRepository orderJpaRepository, OrderMapper orderMapper)");
        }

        @Test
        @DisplayName("should import required classes")
        void shouldImportRequiredClasses() {
            DomainType type = simpleAggregateRoot("Order", DOMAIN_PKG);
            Port port = simpleRepository("Order", DOMAIN_PKG, DOMAIN_PKG + ".OrderId");

            String code = generator.generateAdapter(port, type);

            assertThat(code).contains("import org.springframework.stereotype.Component;");
            assertThat(code).contains("import org.springframework.transaction.annotation.Transactional;");
            assertThat(code).contains("import " + DOMAIN_PKG + ".Order;");
            assertThat(code).contains("import " + DOMAIN_PKG + ".OrderId;");
        }

        @Test
        @DisplayName("should generate javadoc")
        void shouldGenerateJavadoc() {
            DomainType type = simpleAggregateRoot("Order", DOMAIN_PKG);
            Port port = simpleRepository("Order", DOMAIN_PKG, DOMAIN_PKG + ".OrderId");

            String code = generator.generateAdapter(port, type);

            assertThat(code).contains("JPA adapter implementing {@link OrderRepository}");
            assertThat(code).contains("Generated by HexaGlue JPA Plugin");
        }
    }

    @Nested
    @DisplayName("save() method implementation")
    class SaveMethodTests {

        @Test
        @DisplayName("should implement save method")
        void shouldImplementSaveMethod() {
            DomainType type = simpleAggregateRoot("Order", DOMAIN_PKG);
            Port port = simpleRepository("Order", DOMAIN_PKG, DOMAIN_PKG + ".OrderId");

            String code = generator.generateAdapter(port, type);

            assertThat(code).contains("@Override");
            assertThat(code).contains("public Order save(Order param0)");
            assertThat(code).contains("var entity = orderMapper.toEntity(param0);");
            assertThat(code).contains("var saved = orderJpaRepository.save(entity);");
            assertThat(code).contains("return orderMapper.toDomain(saved);");
        }
    }

    @Nested
    @DisplayName("findById() method implementation")
    class FindByIdMethodTests {

        @Test
        @DisplayName("should implement findById with wrapped identity")
        void shouldImplementFindByIdWithWrappedIdentity() {
            DomainType type = simpleAggregateRoot("Order", DOMAIN_PKG);
            Port port = simpleRepository("Order", DOMAIN_PKG, DOMAIN_PKG + ".OrderId");

            String code = generator.generateAdapter(port, type);

            assertThat(code).contains("public Optional<Order> findById(OrderId param0)");
            assertThat(code).contains("return orderJpaRepository.findById(param0.value())");
            assertThat(code).contains(".map(orderMapper::toDomain);");
        }

        @Test
        @DisplayName("should implement findById with raw UUID")
        void shouldImplementFindByIdWithRawUuid() {
            DomainType type = simpleEntity("Order", DOMAIN_PKG);
            Port port = simpleRepository("Order", DOMAIN_PKG, "java.util.UUID");

            String code = generator.generateAdapter(port, type);

            assertThat(code).contains("public Optional<Order> findById(UUID param0)");
            assertThat(code).contains("return orderJpaRepository.findById(param0)");
        }

        @Test
        @DisplayName("should import Optional when findById returns Optional")
        void shouldImportOptionalWhenUsed() {
            DomainType type = simpleAggregateRoot("Order", DOMAIN_PKG);
            Port port = simpleRepository("Order", DOMAIN_PKG, DOMAIN_PKG + ".OrderId");

            String code = generator.generateAdapter(port, type);

            assertThat(code).contains("import java.util.Optional;");
        }
    }

    @Nested
    @DisplayName("findAll() method implementation")
    class FindAllMethodTests {

        @Test
        @DisplayName("should implement findAll method")
        void shouldImplementFindAllMethod() {
            DomainType type = simpleAggregateRoot("Order", DOMAIN_PKG);
            Port port = simpleRepository("Order", DOMAIN_PKG, DOMAIN_PKG + ".OrderId");

            String code = generator.generateAdapter(port, type);

            assertThat(code).contains("public List<Order> findAll()");
            assertThat(code).contains("return orderMapper.toDomainList(orderJpaRepository.findAll());");
        }

        @Test
        @DisplayName("should import List when findAll returns List")
        void shouldImportListWhenUsed() {
            DomainType type = simpleAggregateRoot("Order", DOMAIN_PKG);
            Port port = simpleRepository("Order", DOMAIN_PKG, DOMAIN_PKG + ".OrderId");

            String code = generator.generateAdapter(port, type);

            assertThat(code).contains("import java.util.List;");
        }
    }

    @Nested
    @DisplayName("delete() method implementation")
    class DeleteMethodTests {

        @Test
        @DisplayName("should implement delete with domain object")
        void shouldImplementDeleteWithDomainObject() {
            DomainType type = simpleAggregateRoot("Order", DOMAIN_PKG);
            Port port = simpleRepository("Order", DOMAIN_PKG, DOMAIN_PKG + ".OrderId");

            String code = generator.generateAdapter(port, type);

            assertThat(code).contains("public void delete(Order param0)");
            assertThat(code).contains("var entity = orderMapper.toEntity(param0);");
            assertThat(code).contains("orderJpaRepository.delete(entity);");
        }
    }

    @Nested
    @DisplayName("Custom findBy methods")
    class CustomFindByMethodsTests {

        @Test
        @DisplayName("should generate TODO for custom findBy methods")
        void shouldGenerateTodoForCustomFindByMethods() {
            DomainType type = simpleAggregateRoot("Customer", DOMAIN_PKG);
            Port port = repositoryWithCustomMethods("Customer", DOMAIN_PKG, DOMAIN_PKG + ".CustomerId");

            String code = generator.generateAdapter(port, type);

            assertThat(code).contains("public Optional<Customer> findByEmail(Email param0)");
            assertThat(code).contains("// TODO: Implement custom query or delegate to repository");
            assertThat(code).contains("throw new UnsupportedOperationException");
        }

        @Test
        @DisplayName("should import domain parameter types for custom methods")
        void shouldImportDomainParameterTypesForCustomMethods() {
            DomainType type = simpleAggregateRoot("Customer", DOMAIN_PKG);
            Port port = repositoryWithCustomMethods("Customer", DOMAIN_PKG, DOMAIN_PKG + ".CustomerId");

            String code = generator.generateAdapter(port, type);

            // This is the bug we fixed! Parameter types must be imported
            assertThat(code).contains("import " + DOMAIN_PKG + ".Email;");
            assertThat(code).contains("import " + DOMAIN_PKG + ".CustomerId;");
        }

        @Test
        @DisplayName("should handle findByCustomerId method")
        void shouldHandleFindByCustomerIdMethod() {
            DomainType type = simpleAggregateRoot("Order", DOMAIN_PKG);
            Port port = new Port(
                    DOMAIN_PKG + ".ports.out.OrderRepository",
                    "OrderRepository",
                    DOMAIN_PKG + ".ports.out",
                    PortKind.REPOSITORY,
                    PortDirection.DRIVEN,
                    ConfidenceLevel.HIGH,
                    List.of(DOMAIN_PKG + ".Order"),
                    List.of(
                            new PortMethod("save", DOMAIN_PKG + ".Order", List.of(DOMAIN_PKG + ".Order")),
                            new PortMethod(
                                    "findByCustomerId",
                                    "java.util.List<" + DOMAIN_PKG + ".Order>",
                                    List.of(DOMAIN_PKG + ".CustomerId"))),
                    List.of(),
                    SourceRef.unknown());

            String code = generator.generateAdapter(port, type);

            assertThat(code).contains("public List<Order> findByCustomerId(CustomerId param0)");
            assertThat(code).contains("import " + DOMAIN_PKG + ".CustomerId;");
        }
    }

    @Nested
    @DisplayName("existsBy methods")
    class ExistsByMethodsTests {

        @Test
        @DisplayName("should implement existsById with wrapped identity")
        void shouldImplementExistsByIdWithWrappedIdentity() {
            DomainType type = simpleAggregateRoot("Order", DOMAIN_PKG);
            Port port = new Port(
                    DOMAIN_PKG + ".ports.out.OrderRepository",
                    "OrderRepository",
                    DOMAIN_PKG + ".ports.out",
                    PortKind.REPOSITORY,
                    PortDirection.DRIVEN,
                    ConfidenceLevel.HIGH,
                    List.of(DOMAIN_PKG + ".Order"),
                    List.of(new PortMethod("existsById", "boolean", List.of(DOMAIN_PKG + ".OrderId"))),
                    List.of(),
                    SourceRef.unknown());

            String code = generator.generateAdapter(port, type);

            assertThat(code).contains("public boolean existsById(OrderId param0)");
            assertThat(code).contains("return orderJpaRepository.existsById(param0.value());");
        }

        @Test
        @DisplayName("should generate TODO for existsByEmail")
        void shouldGenerateTodoForExistsByEmail() {
            DomainType type = simpleAggregateRoot("Customer", DOMAIN_PKG);
            Port port = repositoryWithCustomMethods("Customer", DOMAIN_PKG, DOMAIN_PKG + ".CustomerId");

            String code = generator.generateAdapter(port, type);

            assertThat(code).contains("public boolean existsByEmail(Email param0)");
            assertThat(code).contains("throw new UnsupportedOperationException");
        }
    }

    @Nested
    @DisplayName("deleteById method")
    class DeleteByIdMethodTests {

        @Test
        @DisplayName("should implement deleteById with wrapped identity")
        void shouldImplementDeleteByIdWithWrappedIdentity() {
            DomainType type = simpleAggregateRoot("Order", DOMAIN_PKG);
            Port port = new Port(
                    DOMAIN_PKG + ".ports.out.OrderRepository",
                    "OrderRepository",
                    DOMAIN_PKG + ".ports.out",
                    PortKind.REPOSITORY,
                    PortDirection.DRIVEN,
                    ConfidenceLevel.HIGH,
                    List.of(DOMAIN_PKG + ".Order"),
                    List.of(new PortMethod("deleteById", "void", List.of(DOMAIN_PKG + ".OrderId"))),
                    List.of(),
                    SourceRef.unknown());

            String code = generator.generateAdapter(port, type);

            assertThat(code).contains("public void deleteById(OrderId param0)");
            assertThat(code).contains("orderJpaRepository.deleteById(param0.value());");
        }

        @Test
        @DisplayName("should implement deleteById with raw UUID")
        void shouldImplementDeleteByIdWithRawUuid() {
            DomainType type = simpleEntity("Order", DOMAIN_PKG);
            Port port = new Port(
                    DOMAIN_PKG + ".ports.out.OrderRepository",
                    "OrderRepository",
                    DOMAIN_PKG + ".ports.out",
                    PortKind.REPOSITORY,
                    PortDirection.DRIVEN,
                    ConfidenceLevel.HIGH,
                    List.of(DOMAIN_PKG + ".Order"),
                    List.of(new PortMethod("deleteById", "void", List.of("java.util.UUID"))),
                    List.of(),
                    SourceRef.unknown());

            String code = generator.generateAdapter(port, type);

            assertThat(code).contains("public void deleteById(UUID param0)");
            assertThat(code).contains("orderJpaRepository.deleteById(param0);");
        }
    }

    @Nested
    @DisplayName("count() method")
    class CountMethodTests {

        @Test
        @DisplayName("should implement count method")
        void shouldImplementCountMethod() {
            DomainType type = simpleAggregateRoot("Order", DOMAIN_PKG);
            Port port = new Port(
                    DOMAIN_PKG + ".ports.out.OrderRepository",
                    "OrderRepository",
                    DOMAIN_PKG + ".ports.out",
                    PortKind.REPOSITORY,
                    PortDirection.DRIVEN,
                    ConfidenceLevel.HIGH,
                    List.of(DOMAIN_PKG + ".Order"),
                    List.of(new PortMethod("count", "long", List.of())),
                    List.of(),
                    SourceRef.unknown());

            String code = generator.generateAdapter(port, type);

            assertThat(code).contains("public long count()");
            assertThat(code).contains("return orderJpaRepository.count();");
        }
    }

    @Nested
    @DisplayName("Return type inference")
    class ReturnTypeInferenceTests {

        @Test
        @DisplayName("should infer Optional<Domain> for Optional return type")
        void shouldInferOptionalDomainForOptionalReturnType() {
            DomainType type = simpleAggregateRoot("Order", DOMAIN_PKG);
            Port port = new Port(
                    DOMAIN_PKG + ".ports.out.OrderRepository",
                    "OrderRepository",
                    DOMAIN_PKG + ".ports.out",
                    PortKind.REPOSITORY,
                    PortDirection.DRIVEN,
                    ConfidenceLevel.HIGH,
                    List.of(DOMAIN_PKG + ".Order"),
                    List.of(new PortMethod("findById", "Optional", List.of(DOMAIN_PKG + ".OrderId"))),
                    List.of(),
                    SourceRef.unknown());

            String code = generator.generateAdapter(port, type);

            assertThat(code).contains("public Optional<Order> findById(OrderId param0)");
        }

        @Test
        @DisplayName("should infer List<Domain> for List return type")
        void shouldInferListDomainForListReturnType() {
            DomainType type = simpleAggregateRoot("Order", DOMAIN_PKG);
            Port port = new Port(
                    DOMAIN_PKG + ".ports.out.OrderRepository",
                    "OrderRepository",
                    DOMAIN_PKG + ".ports.out",
                    PortKind.REPOSITORY,
                    PortDirection.DRIVEN,
                    ConfidenceLevel.HIGH,
                    List.of(DOMAIN_PKG + ".Order"),
                    List.of(new PortMethod("findAll", "List", List.of())),
                    List.of(),
                    SourceRef.unknown());

            String code = generator.generateAdapter(port, type);

            assertThat(code).contains("public List<Order> findAll()");
        }
    }

    @Nested
    @DisplayName("Custom suffix configuration")
    class CustomSuffixTests {

        @Test
        @DisplayName("should use custom adapter suffix")
        void shouldUseCustomAdapterSuffix() {
            JpaConfig customConfig = new JpaConfig(
                    "Entity", "JpaRepository", "RepositoryImpl", "Mapper", "", false, false, true, true, true);
            JpaAdapterGenerator gen = new JpaAdapterGenerator(INFRA_PKG, customConfig);
            DomainType type = simpleAggregateRoot("Order", DOMAIN_PKG);
            Port port = simpleRepository("Order", DOMAIN_PKG, DOMAIN_PKG + ".OrderId");

            String code = gen.generateAdapter(port, type);

            assertThat(code).contains("public class OrderRepositoryImpl implements OrderRepository {");
        }

        @Test
        @DisplayName("should use custom repository suffix in field names")
        void shouldUseCustomRepositorySuffixInFieldNames() {
            JpaConfig customConfig =
                    new JpaConfig("Entity", "Repo", "Adapter", "Mapper", "", false, false, true, true, true);
            JpaAdapterGenerator gen = new JpaAdapterGenerator(INFRA_PKG, customConfig);
            DomainType type = simpleAggregateRoot("Order", DOMAIN_PKG);
            Port port = simpleRepository("Order", DOMAIN_PKG, DOMAIN_PKG + ".OrderId");

            String code = gen.generateAdapter(port, type);

            assertThat(code).contains("private final OrderRepo orderRepo;");
        }
    }

    @Nested
    @DisplayName("Identity wrapper type detection")
    class IdentityWrapperTypeDetectionTests {

        @Test
        @DisplayName("should detect OrderId as wrapper type")
        void shouldDetectOrderIdAsWrapperType() {
            DomainType type = simpleAggregateRoot("Order", DOMAIN_PKG);
            Port port = simpleRepository("Order", DOMAIN_PKG, DOMAIN_PKG + ".OrderId");

            String code = generator.generateAdapter(port, type);

            // OrderId should call .value() to unwrap
            assertThat(code).contains("param0.value()");
        }

        @Test
        @DisplayName("should NOT unwrap UUID type")
        void shouldNotUnwrapUuidType() {
            DomainType type = simpleEntity("Order", DOMAIN_PKG);
            Port port = simpleRepository("Order", DOMAIN_PKG, "java.util.UUID");

            String code = generator.generateAdapter(port, type);

            // UUID should NOT call .value()
            assertThat(code).doesNotContain("param0.value()");
        }

        @Test
        @DisplayName("should NOT unwrap Long type")
        void shouldNotUnwrapLongType() {
            DomainType type = simpleEntity("Order", DOMAIN_PKG);
            Port port = simpleRepository("Order", DOMAIN_PKG, "java.lang.Long");

            String code = generator.generateAdapter(port, type);

            // Long should NOT call .value()
            assertThat(code).doesNotContain("param0.value()");
        }

        @Test
        @DisplayName("should NOT unwrap String type")
        void shouldNotUnwrapStringType() {
            DomainType type = simpleEntity("Order", DOMAIN_PKG);
            Port port = simpleRepository("Order", DOMAIN_PKG, "java.lang.String");

            String code = generator.generateAdapter(port, type);

            // String should NOT call .value()
            assertThat(code).doesNotContain("param0.value()");
        }

        @Test
        @DisplayName("should detect CustomerId as wrapper type")
        void shouldDetectCustomerIdAsWrapperType() {
            DomainType type = simpleAggregateRoot("Customer", DOMAIN_PKG);
            Port port = simpleRepository("Customer", DOMAIN_PKG, DOMAIN_PKG + ".CustomerId");

            String code = generator.generateAdapter(port, type);

            assertThat(code).contains("param0.value()");
        }
    }
}
