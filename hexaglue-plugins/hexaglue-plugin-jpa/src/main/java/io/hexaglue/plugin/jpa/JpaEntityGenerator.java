package io.hexaglue.plugin.jpa;

import io.hexaglue.spi.ir.Cardinality;
import io.hexaglue.spi.ir.DomainProperty;
import io.hexaglue.spi.ir.DomainRelation;
import io.hexaglue.spi.ir.DomainType;
import io.hexaglue.spi.ir.Identity;
import java.util.HashSet;
import java.util.Set;

/**
 * Generates JPA entity source code from domain types.
 */
final class JpaEntityGenerator {

    private final String infrastructurePackage;
    private final JpaConfig config;

    JpaEntityGenerator(String infrastructurePackage, JpaConfig config) {
        this.infrastructurePackage = infrastructurePackage;
        this.config = config;
    }

    /**
     * Generates JPA entity class for a domain entity or aggregate root.
     */
    String generateEntity(DomainType domainType) {
        String entityName = domainType.simpleName() + config.entitySuffix();
        StringBuilder sb = new StringBuilder();
        Set<String> imports = new HashSet<>();

        // Collect imports
        imports.add("jakarta.persistence.Entity");
        imports.add("jakarta.persistence.Id");
        imports.add("jakarta.persistence.Table");

        if (domainType.hasIdentity()) {
            Identity id = domainType.identity().get();
            collectIdImports(imports, id);
        }

        collectPropertyImports(imports, domainType);
        collectRelationImports(imports, domainType);

        if (config.enableAuditing()) {
            imports.add("org.springframework.data.annotation.CreatedDate");
            imports.add("org.springframework.data.annotation.LastModifiedDate");
            imports.add("org.springframework.data.jpa.domain.support.AuditingEntityListener");
            imports.add("jakarta.persistence.EntityListeners");
            imports.add("java.time.Instant");
        }

        if (config.enableOptimisticLocking()) {
            imports.add("jakarta.persistence.Version");
        }

        // Package
        sb.append("package ").append(infrastructurePackage).append(";\n\n");

        // Imports
        imports.stream()
                .sorted()
                .forEach(imp -> sb.append("import ").append(imp).append(";\n"));
        sb.append("\n");

        // Class javadoc
        sb.append("/**\n");
        sb.append(" * JPA entity for {@link ")
                .append(domainType.qualifiedName())
                .append("}.\n");
        sb.append(" *\n");
        sb.append(" * <p>Generated by HexaGlue JPA Plugin.\n");
        sb.append(" */\n");

        // Annotations
        sb.append("@Entity\n");
        sb.append("@Table(name = \"")
                .append(config.tablePrefix())
                .append(toSnakeCase(domainType.simpleName()))
                .append("\")\n");

        if (config.enableAuditing()) {
            sb.append("@EntityListeners(AuditingEntityListener.class)\n");
        }

        // Class declaration
        sb.append("public class ").append(entityName).append(" {\n\n");

        // Identity field
        domainType.identity().ifPresent(id -> generateIdentityField(sb, id));

        // Properties
        for (DomainProperty prop : domainType.properties()) {
            if (!prop.isIdentity()) {
                generatePropertyField(sb, prop, domainType);
            }
        }

        // Auditing fields
        if (config.enableAuditing()) {
            generateAuditingFields(sb);
        }

        // Version field for optimistic locking
        if (config.enableOptimisticLocking()) {
            generateVersionField(sb);
        }

        // Default constructor for JPA
        sb.append("    /**\n");
        sb.append("     * Default constructor for JPA.\n");
        sb.append("     */\n");
        sb.append("    protected ").append(entityName).append("() {\n");
        sb.append("    }\n\n");

        // Getters and setters
        domainType.identity().ifPresent(id -> generateIdAccessors(sb, id));
        for (DomainProperty prop : domainType.properties()) {
            if (!prop.isIdentity()) {
                generatePropertyAccessors(sb, prop, domainType);
            }
        }

        if (config.enableAuditing()) {
            generateAuditingAccessors(sb);
        }

        if (config.enableOptimisticLocking()) {
            generateVersionAccessors(sb);
        }

        sb.append("}\n");

        return sb.toString();
    }

    /**
     * Generates JPA embeddable class for a value object.
     */
    String generateEmbeddable(DomainType valueObject) {
        String embeddableName = valueObject.simpleName() + "Embeddable";
        StringBuilder sb = new StringBuilder();
        Set<String> imports = new HashSet<>();

        imports.add("jakarta.persistence.Embeddable");
        collectPropertyImports(imports, valueObject);

        // Package
        sb.append("package ").append(infrastructurePackage).append(";\n\n");

        // Imports
        imports.stream()
                .sorted()
                .forEach(imp -> sb.append("import ").append(imp).append(";\n"));
        sb.append("\n");

        // Class javadoc
        sb.append("/**\n");
        sb.append(" * JPA embeddable for {@link ")
                .append(valueObject.qualifiedName())
                .append("}.\n");
        sb.append(" *\n");
        sb.append(" * <p>Generated by HexaGlue JPA Plugin.\n");
        sb.append(" */\n");

        // Annotations
        sb.append("@Embeddable\n");

        // Class declaration
        sb.append("public class ").append(embeddableName).append(" {\n\n");

        // Properties
        for (DomainProperty prop : valueObject.properties()) {
            generateSimpleField(sb, prop);
        }

        // Default constructor for JPA
        sb.append("    /**\n");
        sb.append("     * Default constructor for JPA.\n");
        sb.append("     */\n");
        sb.append("    protected ").append(embeddableName).append("() {\n");
        sb.append("    }\n\n");

        // All-args constructor
        generateAllArgsConstructor(sb, embeddableName, valueObject);

        // Getters
        for (DomainProperty prop : valueObject.properties()) {
            generateGetter(sb, prop);
        }

        sb.append("}\n");

        return sb.toString();
    }

    private void collectIdImports(Set<String> imports, Identity id) {
        String typeName = id.unwrappedType().qualifiedName();
        if (typeName.equals("java.util.UUID")) {
            imports.add("java.util.UUID");
        }
        if (id.strategy() == io.hexaglue.spi.ir.IdentityStrategy.AUTO
                || id.strategy() == io.hexaglue.spi.ir.IdentityStrategy.SEQUENCE) {
            imports.add("jakarta.persistence.GeneratedValue");
            imports.add("jakarta.persistence.GenerationType");
        }
    }

    private void collectPropertyImports(Set<String> imports, DomainType type) {
        for (DomainProperty prop : type.properties()) {
            String typeName = prop.type().unwrapElement().qualifiedName();
            if (needsImport(typeName)) {
                imports.add(typeName);
            }
            if (prop.cardinality() == Cardinality.COLLECTION) {
                imports.add("java.util.List");
                imports.add("java.util.ArrayList");
            }
            if (prop.isEmbedded()) {
                imports.add("jakarta.persistence.Embedded");
            }
        }
    }

    private void collectRelationImports(Set<String> imports, DomainType type) {
        for (DomainRelation rel : type.relations()) {
            switch (rel.kind()) {
                case ONE_TO_ONE -> imports.add("jakarta.persistence.OneToOne");
                case ONE_TO_MANY -> {
                    imports.add("jakarta.persistence.OneToMany");
                    imports.add("jakarta.persistence.CascadeType");
                    imports.add("java.util.List");
                    imports.add("java.util.ArrayList");
                }
                case MANY_TO_ONE -> imports.add("jakarta.persistence.ManyToOne");
                case MANY_TO_MANY -> {
                    imports.add("jakarta.persistence.ManyToMany");
                    imports.add("java.util.Set");
                    imports.add("java.util.HashSet");
                }
                case EMBEDDED -> imports.add("jakarta.persistence.Embedded");
                case ELEMENT_COLLECTION -> {
                    imports.add("jakarta.persistence.ElementCollection");
                    imports.add("jakarta.persistence.CollectionTable");
                    imports.add("java.util.List");
                    imports.add("java.util.ArrayList");
                }
            }
        }
    }

    private boolean needsImport(String typeName) {
        return typeName.contains(".") && !typeName.startsWith("java.lang.") && !typeName.equals("java.lang.String");
    }

    private void generateIdentityField(StringBuilder sb, Identity id) {
        sb.append("    @Id\n");

        if (id.strategy() == io.hexaglue.spi.ir.IdentityStrategy.AUTO) {
            sb.append("    @GeneratedValue(strategy = GenerationType.AUTO)\n");
        } else if (id.strategy() == io.hexaglue.spi.ir.IdentityStrategy.SEQUENCE) {
            sb.append("    @GeneratedValue(strategy = GenerationType.SEQUENCE)\n");
        }

        String jpaType = mapToJpaType(id.unwrappedType().qualifiedName());
        sb.append("    private ")
                .append(jpaType)
                .append(" ")
                .append(id.fieldName())
                .append(";\n\n");
    }

    private void generatePropertyField(StringBuilder sb, DomainProperty prop, DomainType domainType) {
        // Check if this property has a relation
        DomainRelation relation = findRelationForProperty(prop, domainType);

        if (relation != null) {
            generateRelationField(sb, prop, relation);
        } else if (prop.isEmbedded()) {
            sb.append("    @Embedded\n");
            String embeddableType = prop.type().simpleName() + "Embeddable";
            sb.append("    private ")
                    .append(embeddableType)
                    .append(" ")
                    .append(prop.name())
                    .append(";\n\n");
        } else {
            generateSimpleField(sb, prop);
        }
    }

    private DomainRelation findRelationForProperty(DomainProperty prop, DomainType type) {
        return type.relations().stream()
                .filter(r -> r.propertyName().equals(prop.name()))
                .findFirst()
                .orElse(null);
    }

    private void generateRelationField(StringBuilder sb, DomainProperty prop, DomainRelation relation) {
        String targetEntity = relation.targetSimpleName() + config.entitySuffix();

        switch (relation.kind()) {
            case ONE_TO_ONE -> {
                sb.append("    @OneToOne");
                if (relation.mappedBy() != null) {
                    sb.append("(mappedBy = \"").append(relation.mappedBy()).append("\")");
                }
                sb.append("\n");
                sb.append("    private ")
                        .append(targetEntity)
                        .append(" ")
                        .append(prop.name())
                        .append(";\n\n");
            }
            case ONE_TO_MANY -> {
                sb.append("    @OneToMany(");
                if (relation.mappedBy() != null) {
                    sb.append("mappedBy = \"").append(relation.mappedBy()).append("\", ");
                }
                sb.append("cascade = CascadeType.ALL, orphanRemoval = true)\n");
                sb.append("    private List<")
                        .append(targetEntity)
                        .append("> ")
                        .append(prop.name())
                        .append(" = new ArrayList<>();\n\n");
            }
            case MANY_TO_ONE -> {
                sb.append("    @ManyToOne\n");
                sb.append("    private ")
                        .append(targetEntity)
                        .append(" ")
                        .append(prop.name())
                        .append(";\n\n");
            }
            case MANY_TO_MANY -> {
                sb.append("    @ManyToMany");
                if (relation.mappedBy() != null) {
                    sb.append("(mappedBy = \"").append(relation.mappedBy()).append("\")");
                }
                sb.append("\n");
                sb.append("    private Set<")
                        .append(targetEntity)
                        .append("> ")
                        .append(prop.name())
                        .append(" = new HashSet<>();\n\n");
            }
            case EMBEDDED -> {
                sb.append("    @Embedded\n");
                String embeddableType = relation.targetSimpleName() + "Embeddable";
                sb.append("    private ")
                        .append(embeddableType)
                        .append(" ")
                        .append(prop.name())
                        .append(";\n\n");
            }
            case ELEMENT_COLLECTION -> {
                String embeddableType = relation.targetSimpleName() + "Embeddable";
                sb.append("    @ElementCollection\n");
                sb.append("    @CollectionTable(name = \"")
                        .append(toSnakeCase(prop.name()))
                        .append("\")\n");
                sb.append("    private List<")
                        .append(embeddableType)
                        .append("> ")
                        .append(prop.name())
                        .append(" = new ArrayList<>();\n\n");
            }
        }
    }

    private void generateSimpleField(StringBuilder sb, DomainProperty prop) {
        String jpaType = mapToJpaType(prop.type().unwrapElement().qualifiedName());

        if (prop.cardinality() == Cardinality.COLLECTION) {
            sb.append("    private List<")
                    .append(jpaType)
                    .append("> ")
                    .append(prop.name())
                    .append(";\n\n");
        } else {
            sb.append("    private ")
                    .append(jpaType)
                    .append(" ")
                    .append(prop.name())
                    .append(";\n\n");
        }
    }

    private void generateAuditingFields(StringBuilder sb) {
        sb.append("    @CreatedDate\n");
        sb.append("    private Instant createdAt;\n\n");

        sb.append("    @LastModifiedDate\n");
        sb.append("    private Instant updatedAt;\n\n");
    }

    private void generateVersionField(StringBuilder sb) {
        sb.append("    @Version\n");
        sb.append("    private Long version;\n\n");
    }

    private void generateIdAccessors(StringBuilder sb, Identity id) {
        String jpaType = mapToJpaType(id.unwrappedType().qualifiedName());
        String fieldName = id.fieldName();
        String capName = capitalize(fieldName);

        sb.append("    public ").append(jpaType).append(" get").append(capName).append("() {\n");
        sb.append("        return ").append(fieldName).append(";\n");
        sb.append("    }\n\n");

        sb.append("    public void set")
                .append(capName)
                .append("(")
                .append(jpaType)
                .append(" ")
                .append(fieldName)
                .append(") {\n");
        sb.append("        this.")
                .append(fieldName)
                .append(" = ")
                .append(fieldName)
                .append(";\n");
        sb.append("    }\n\n");
    }

    private void generatePropertyAccessors(StringBuilder sb, DomainProperty prop, DomainType domainType) {
        String fieldType = getFieldType(prop, domainType);
        String fieldName = prop.name();
        String capName = capitalize(fieldName);

        // Getter
        sb.append("    public ")
                .append(fieldType)
                .append(" get")
                .append(capName)
                .append("() {\n");
        sb.append("        return ").append(fieldName).append(";\n");
        sb.append("    }\n\n");

        // Setter
        sb.append("    public void set")
                .append(capName)
                .append("(")
                .append(fieldType)
                .append(" ")
                .append(fieldName)
                .append(") {\n");
        sb.append("        this.")
                .append(fieldName)
                .append(" = ")
                .append(fieldName)
                .append(";\n");
        sb.append("    }\n\n");
    }

    private void generateGetter(StringBuilder sb, DomainProperty prop) {
        String jpaType = mapToJpaType(prop.type().unwrapElement().qualifiedName());
        String fieldName = prop.name();
        String capName = capitalize(fieldName);

        sb.append("    public ").append(jpaType).append(" get").append(capName).append("() {\n");
        sb.append("        return ").append(fieldName).append(";\n");
        sb.append("    }\n\n");
    }

    private void generateAuditingAccessors(StringBuilder sb) {
        sb.append("    public Instant getCreatedAt() {\n");
        sb.append("        return createdAt;\n");
        sb.append("    }\n\n");

        sb.append("    public Instant getUpdatedAt() {\n");
        sb.append("        return updatedAt;\n");
        sb.append("    }\n\n");
    }

    private void generateVersionAccessors(StringBuilder sb) {
        sb.append("    public Long getVersion() {\n");
        sb.append("        return version;\n");
        sb.append("    }\n\n");
    }

    private void generateAllArgsConstructor(StringBuilder sb, String className, DomainType type) {
        sb.append("    public ").append(className).append("(");

        boolean first = true;
        for (DomainProperty prop : type.properties()) {
            if (!first) sb.append(", ");
            String jpaType = mapToJpaType(prop.type().unwrapElement().qualifiedName());
            sb.append(jpaType).append(" ").append(prop.name());
            first = false;
        }
        sb.append(") {\n");

        for (DomainProperty prop : type.properties()) {
            sb.append("        this.")
                    .append(prop.name())
                    .append(" = ")
                    .append(prop.name())
                    .append(";\n");
        }
        sb.append("    }\n\n");
    }

    private String getFieldType(DomainProperty prop, DomainType domainType) {
        // Check if this property has a relation
        DomainRelation relation = findRelationForProperty(prop, domainType);

        if (relation != null) {
            String targetEntity = relation.targetSimpleName() + config.entitySuffix();
            return switch (relation.kind()) {
                case ONE_TO_ONE, MANY_TO_ONE -> targetEntity;
                case ONE_TO_MANY -> "List<" + targetEntity + ">";
                case MANY_TO_MANY -> "Set<" + targetEntity + ">";
                case EMBEDDED -> relation.targetSimpleName() + "Embeddable";
                case ELEMENT_COLLECTION -> "List<" + relation.targetSimpleName() + "Embeddable>";
            };
        }

        String baseType = mapToJpaType(prop.type().unwrapElement().qualifiedName());
        if (prop.isEmbedded()) {
            return prop.type().simpleName() + "Embeddable";
        }
        if (prop.cardinality() == Cardinality.COLLECTION) {
            return "List<" + baseType + ">";
        }
        return baseType;
    }

    private String mapToJpaType(String domainType) {
        return switch (domainType) {
            case "java.util.UUID", "UUID" -> "UUID";
            case "java.lang.String", "String" -> "String";
            case "java.lang.Long", "Long", "long" -> "Long";
            case "java.lang.Integer", "Integer", "int" -> "Integer";
            case "java.math.BigDecimal", "BigDecimal" -> "BigDecimal";
            case "java.time.LocalDate", "LocalDate" -> "LocalDate";
            case "java.time.LocalDateTime", "LocalDateTime" -> "LocalDateTime";
            case "java.time.Instant", "Instant" -> "Instant";
            default -> {
                int lastDot = domainType.lastIndexOf('.');
                yield lastDot >= 0 ? domainType.substring(lastDot + 1) : domainType;
            }
        };
    }

    private String toSnakeCase(String camelCase) {
        return camelCase.replaceAll("([a-z])([A-Z])", "$1_$2").toLowerCase();
    }

    private String capitalize(String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }
        return Character.toUpperCase(str.charAt(0)) + str.substring(1);
    }
}
