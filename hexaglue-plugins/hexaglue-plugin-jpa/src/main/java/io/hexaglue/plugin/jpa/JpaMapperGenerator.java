package io.hexaglue.plugin.jpa;

import io.hexaglue.spi.ir.Cardinality;
import io.hexaglue.spi.ir.DomainKind;
import io.hexaglue.spi.ir.DomainProperty;
import io.hexaglue.spi.ir.DomainRelation;
import io.hexaglue.spi.ir.DomainType;
import io.hexaglue.spi.ir.RelationKind;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;

/**
 * Generates MapStruct mapper interfaces for domain-to-entity conversions.
 */
final class JpaMapperGenerator {

    private final String infrastructurePackage;
    private final JpaConfig config;

    @SuppressWarnings("unused")
    JpaMapperGenerator(String infrastructurePackage, String domainPackage, JpaConfig config) {
        this.infrastructurePackage = infrastructurePackage;
        // domainPackage kept for API compatibility
        this.config = config;
    }

    /**
     * Generates a MapStruct mapper interface for a domain type.
     */
    String generateMapper(DomainType domainType, List<DomainType> allTypes) {
        String domainName = domainType.simpleName();
        String entityName = domainName + config.entitySuffix();
        String mapperName = domainName + config.mapperSuffix();
        StringBuilder sb = new StringBuilder();
        Set<String> imports = new HashSet<>();

        // Collect imports
        imports.add("org.mapstruct.Mapper");
        imports.add("org.mapstruct.Mapping");
        imports.add("org.mapstruct.MappingConstants");

        // Domain import
        imports.add(domainType.qualifiedName());

        // Check for related mappers needed
        Set<String> usesMappers = collectRelatedMappers(domainType, allTypes);

        // Package
        sb.append("package ").append(infrastructurePackage).append(";\n\n");

        // Imports
        imports.stream()
                .sorted()
                .forEach(imp -> sb.append("import ").append(imp).append(";\n"));
        sb.append("\n");

        // Interface javadoc
        sb.append("/**\n");
        sb.append(" * MapStruct mapper for {@link ")
                .append(domainName)
                .append("} ↔ {@link ")
                .append(entityName)
                .append("} conversions.\n");
        sb.append(" *\n");
        sb.append(" * <p>Generated by HexaGlue JPA Plugin.\n");
        sb.append(" */\n");

        // Mapper annotation
        sb.append("@Mapper(componentModel = MappingConstants.ComponentModel.SPRING");
        if (!usesMappers.isEmpty()) {
            sb.append(",\n        uses = {");
            boolean first = true;
            for (String mapper : usesMappers) {
                if (!first) sb.append(", ");
                sb.append(mapper).append(".class");
                first = false;
            }
            sb.append("}");
        }
        sb.append(")\n");

        // Interface declaration
        sb.append("public interface ").append(mapperName).append(" {\n\n");

        // toEntity method
        generateToEntityMethod(sb, domainType, domainName, entityName, allTypes);

        // toDomain method
        generateToDomainMethod(sb, domainType, domainName, entityName, allTypes);

        // List mappings
        generateListMethods(sb, domainName, entityName);

        sb.append("}\n");

        return sb.toString();
    }

    /**
     * Generates a MapStruct mapper for a value object (embeddable).
     */
    String generateValueObjectMapper(DomainType valueObject) {
        String domainName = valueObject.simpleName();
        String embeddableName = domainName + "Embeddable";
        String mapperName = domainName + config.mapperSuffix();
        StringBuilder sb = new StringBuilder();

        // Package
        sb.append("package ").append(infrastructurePackage).append(";\n\n");

        // Imports
        sb.append("import org.mapstruct.BeanMapping;\n");
        sb.append("import org.mapstruct.Mapper;\n");
        sb.append("import org.mapstruct.MappingConstants;\n");
        sb.append("import org.mapstruct.ReportingPolicy;\n");
        sb.append("import ").append(valueObject.qualifiedName()).append(";\n");
        sb.append("\n");

        // Interface javadoc
        sb.append("/**\n");
        sb.append(" * MapStruct mapper for {@link ")
                .append(domainName)
                .append("} ↔ {@link ")
                .append(embeddableName)
                .append("} conversions.\n");
        sb.append(" *\n");
        sb.append(" * <p>Generated by HexaGlue JPA Plugin.\n");
        sb.append(" */\n");

        // Mapper annotation
        sb.append("@Mapper(componentModel = MappingConstants.ComponentModel.SPRING)\n");

        // Interface declaration
        sb.append("public interface ").append(mapperName).append(" {\n\n");

        // toEmbeddable method
        sb.append("    /**\n");
        sb.append("     * Converts domain value object to JPA embeddable.\n");
        sb.append("     *\n");
        sb.append("     * @param domain the domain value object\n");
        sb.append("     * @return the JPA embeddable\n");
        sb.append("     */\n");
        sb.append("    @BeanMapping(unmappedTargetPolicy = ReportingPolicy.IGNORE)\n");
        sb.append("    ")
                .append(embeddableName)
                .append(" toEmbeddable(")
                .append(domainName)
                .append(" domain);\n\n");

        // toDomain method
        sb.append("    /**\n");
        sb.append("     * Converts JPA embeddable to domain value object.\n");
        sb.append("     *\n");
        sb.append("     * @param entity the JPA embeddable\n");
        sb.append("     * @return the domain value object\n");
        sb.append("     */\n");
        sb.append("    @BeanMapping(unmappedTargetPolicy = ReportingPolicy.IGNORE)\n");
        sb.append("    ")
                .append(domainName)
                .append(" toDomain(")
                .append(embeddableName)
                .append(" entity);\n\n");

        // List mappings
        sb.append("    /**\n");
        sb.append("     * Converts a list of domain value objects to embeddables.\n");
        sb.append("     */\n");
        sb.append("    java.util.List<")
                .append(embeddableName)
                .append("> toEmbeddableList(java.util.List<")
                .append(domainName)
                .append("> domains);\n\n");

        sb.append("    /**\n");
        sb.append("     * Converts a list of embeddables to domain value objects.\n");
        sb.append("     */\n");
        sb.append("    java.util.List<")
                .append(domainName)
                .append("> toDomainList(java.util.List<")
                .append(embeddableName)
                .append("> entities);\n\n");

        sb.append("}\n");

        return sb.toString();
    }

    private Set<String> collectRelatedMappers(DomainType domainType, List<DomainType> allTypes) {
        Set<String> mappers = new HashSet<>();

        for (DomainRelation rel : domainType.relations()) {
            if (rel.kind() == RelationKind.EMBEDDED || rel.kind() == RelationKind.ELEMENT_COLLECTION) {
                // Value object mappers
                String targetMapper = rel.targetSimpleName() + config.mapperSuffix();
                mappers.add(targetMapper);
            } else if (rel.kind() == RelationKind.ONE_TO_MANY && rel.targetsEntity()) {
                // Entity mappers for one-to-many relationships (e.g., Order -> OrderLine)
                String targetMapper = rel.targetSimpleName() + config.mapperSuffix();
                mappers.add(targetMapper);
            }
        }

        // Also check properties for embedded value objects
        for (DomainProperty prop : domainType.properties()) {
            if (prop.isEmbedded() && prop.cardinality() == Cardinality.SINGLE) {
                String propTypeName = prop.type().simpleName();
                // Check if this is a value object in our types
                boolean isValueObject =
                        allTypes.stream().anyMatch(t -> t.simpleName().equals(propTypeName) && t.isValueObject());
                if (isValueObject) {
                    mappers.add(propTypeName + config.mapperSuffix());
                }
            }
        }

        // Check if identity is a composite identifier (multi-property) - needs embedded mapper
        if (domainType.hasIdentity()) {
            var id = domainType.identity().get();
            String idTypeName = id.type().qualifiedName();
            Optional<DomainType> idType = allTypes.stream()
                    .filter(t -> t.qualifiedName().equals(idTypeName))
                    .filter(t -> t.kind() == DomainKind.IDENTIFIER)
                    .filter(t -> t.properties().size() > 1) // Composite = multiple properties
                    .findFirst();
            if (idType.isPresent()) {
                mappers.add(idType.get().simpleName() + config.mapperSuffix());
            }
        }

        return mappers;
    }

    private void generateToEntityMethod(
            StringBuilder sb, DomainType domainType, String domainName, String entityName, List<DomainType> allTypes) {
        sb.append("    /**\n");
        sb.append("     * Converts domain object to JPA entity.\n");
        sb.append("     *\n");
        sb.append("     * @param domain the domain object\n");
        sb.append("     * @return the JPA entity\n");
        sb.append("     */\n");

        // Add @Mapping annotations for identity unwrapping
        if (domainType.hasIdentity()) {
            var id = domainType.identity().get();
            String idField = id.fieldName();
            // If identity is a wrapped type (like OrderId with UUID value), add mapping
            if (!id.unwrappedType().qualifiedName().equals(id.type().qualifiedName())) {
                sb.append("    @Mapping(source = \"")
                        .append(idField)
                        .append(".value\", target = \"")
                        .append(idField)
                        .append("\")\n");
            }
        }

        // Add @Mapping annotations for single-property Identifiers (like CustomerId -> UUID)
        // Composite identifiers use embeddable mapping via MapStruct's uses clause
        for (DomainProperty prop : domainType.properties()) {
            if (!prop.isIdentity() && !prop.isEmbedded() && !prop.hasRelation()) {
                String propTypeName = prop.type().unwrapElement().qualifiedName();
                Optional<DomainType> identifierType = findSinglePropertyIdentifier(propTypeName, allTypes);
                if (identifierType.isPresent()) {
                    // Map customerId.value -> customerId (unwrap single-property ID)
                    sb.append("    @Mapping(source = \"")
                            .append(prop.name())
                            .append(".value\", target = \"")
                            .append(prop.name())
                            .append("\")\n");
                }
            }
        }

        // Add mappings for embedded value objects
        for (DomainRelation rel : domainType.relations()) {
            if (rel.kind() == RelationKind.EMBEDDED) {
                // MapStruct handles this with uses = {Mapper.class}
            }
        }

        sb.append("    ")
                .append(entityName)
                .append(" toEntity(")
                .append(domainName)
                .append(" domain);\n\n");
    }

    /**
     * Finds a single-property Identifier type by its qualified name.
     * Returns empty for composite identifiers (multi-property) which need embeddable mapping.
     */
    private Optional<DomainType> findSinglePropertyIdentifier(String qualifiedName, List<DomainType> allTypes) {
        return allTypes.stream()
                .filter(t -> t.qualifiedName().equals(qualifiedName))
                .filter(t -> t.kind() == DomainKind.IDENTIFIER)
                .filter(t -> t.properties().size() == 1) // Only single-property identifiers
                .findFirst();
    }

    private void generateToDomainMethod(
            StringBuilder sb, DomainType domainType, String domainName, String entityName, List<DomainType> allTypes) {
        sb.append("    /**\n");
        sb.append("     * Converts JPA entity to domain object.\n");
        sb.append("     *\n");
        sb.append("     * @param entity the JPA entity\n");
        sb.append("     * @return the domain object\n");
        sb.append("     */\n");

        // Add @Mapping annotations for identity wrapping
        if (domainType.hasIdentity()) {
            var id = domainType.identity().get();
            String idField = id.fieldName();
            // If identity is a wrapped type, we need custom expression
            if (!id.unwrappedType().qualifiedName().equals(id.type().qualifiedName())) {
                String idTypeName = getSimpleName(id.type().qualifiedName());
                sb.append("    @Mapping(target = \"")
                        .append(idField)
                        .append("\", expression = \"java(new ")
                        .append(idTypeName)
                        .append("(entity.get")
                        .append(capitalize(idField))
                        .append("()))\")\n");
            }
        }

        // Add @Mapping annotations for single-property Identifiers (like UUID -> CustomerId)
        // Composite identifiers use embeddable mapping via MapStruct's uses clause
        for (DomainProperty prop : domainType.properties()) {
            if (!prop.isIdentity() && !prop.isEmbedded() && !prop.hasRelation()) {
                String propTypeName = prop.type().unwrapElement().qualifiedName();
                Optional<DomainType> identifierType = findSinglePropertyIdentifier(propTypeName, allTypes);
                if (identifierType.isPresent()) {
                    // Map entity.getCustomerId() -> new CustomerId(...) (wrap single-property ID)
                    String idTypeName = getSimpleName(propTypeName);
                    sb.append("    @Mapping(target = \"")
                            .append(prop.name())
                            .append("\", expression = \"java(new ")
                            .append(idTypeName)
                            .append("(entity.get")
                            .append(capitalize(prop.name()))
                            .append("()))\")\n");
                }
            }
        }

        sb.append("    ")
                .append(domainName)
                .append(" toDomain(")
                .append(entityName)
                .append(" entity);\n\n");
    }

    private void generateListMethods(StringBuilder sb, String domainName, String entityName) {
        sb.append("    /**\n");
        sb.append("     * Converts a list of domain objects to entities.\n");
        sb.append("     */\n");
        sb.append("    java.util.List<")
                .append(entityName)
                .append("> toEntityList(java.util.List<")
                .append(domainName)
                .append("> domains);\n\n");

        sb.append("    /**\n");
        sb.append("     * Converts a list of entities to domain objects.\n");
        sb.append("     */\n");
        sb.append("    java.util.List<")
                .append(domainName)
                .append("> toDomainList(java.util.List<")
                .append(entityName)
                .append("> entities);\n\n");
    }

    private String getSimpleName(String qualifiedName) {
        int lastDot = qualifiedName.lastIndexOf('.');
        return lastDot >= 0 ? qualifiedName.substring(lastDot + 1) : qualifiedName;
    }

    private String capitalize(String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }
        return Character.toUpperCase(str.charAt(0)) + str.substring(1);
    }
}
