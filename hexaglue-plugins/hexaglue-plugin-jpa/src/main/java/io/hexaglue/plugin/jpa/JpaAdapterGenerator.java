/*
 * This Source Code Form is part of the HexaGlue project.
 * Copyright (c) 2026 Scalastic
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 *
 * Commercial licensing options are available for organizations wishing
 * to use HexaGlue under terms different from the MPL 2.0.
 * Contact: info@hexaglue.io
 */

package io.hexaglue.plugin.jpa;

import io.hexaglue.spi.ir.DomainType;
import io.hexaglue.spi.ir.Port;
import io.hexaglue.spi.ir.PortMethod;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * Generates JPA adapter classes that implement port interfaces.
 *
 * <p>The adapter bridges the domain port with the JPA infrastructure,
 * using the repository for persistence and mapper for conversions.
 */
final class JpaAdapterGenerator {

    private final String infrastructurePackage;
    private final JpaConfig config;

    JpaAdapterGenerator(String infrastructurePackage, JpaConfig config) {
        this.infrastructurePackage = infrastructurePackage;
        this.config = config;
    }

    /**
     * Generates an adapter class that implements multiple repository ports for the same managed type.
     *
     * <p>When multiple ports manage the same domain type (e.g., OrderSaver and OrderFetcher both
     * manage Order), this method generates a single adapter that implements all of them.
     *
     * @param ports the port interfaces to implement
     * @param managedType the domain type managed by these ports
     * @return the generated adapter source code
     */
    String generateMergedAdapter(List<Port> ports, DomainType managedType) {
        String domainName = managedType.simpleName();
        String repositoryName = domainName + config.repositorySuffix();
        String mapperName = domainName + config.mapperSuffix();
        String adapterName = domainName + config.adapterSuffix();

        StringBuilder sb = new StringBuilder();
        Set<String> imports = new HashSet<>();

        // Collect imports from all ports
        imports.add("javax.annotation.processing.Generated");
        imports.add("org.springframework.stereotype.Component");
        imports.add("org.springframework.transaction.annotation.Transactional");
        imports.add(managedType.qualifiedName());

        for (Port port : ports) {
            imports.add(port.qualifiedName());

            // Add imports for common return types and parameter types based on method signatures
            for (PortMethod method : port.methods()) {
                collectMethodImports(method, imports);
            }
        }

        if (managedType.hasIdentity()) {
            String idTypeName = managedType.identity().get().type().qualifiedName();
            if (idTypeName.contains(".")) {
                imports.add(idTypeName);
            }
        }

        // Package
        sb.append("package ").append(infrastructurePackage).append(";\n\n");

        // Imports
        imports.stream()
                .sorted()
                .forEach(imp -> sb.append("import ").append(imp).append(";\n"));
        sb.append("\n");

        // Class javadoc
        sb.append("/**\n");
        sb.append(" * JPA adapter implementing");
        for (int i = 0; i < ports.size(); i++) {
            if (i > 0) sb.append(",");
            sb.append(" {@link ").append(ports.get(i).simpleName()).append("}");
        }
        sb.append(".\n");
        sb.append(" *\n");
        sb.append(" * <p>Bridges the domain ports with JPA infrastructure using\n");
        sb.append(" * {@link ")
                .append(repositoryName)
                .append("} and {@link ")
                .append(mapperName)
                .append("}.\n");
        sb.append(" *\n");
        sb.append(" * <p>Generated by HexaGlue JPA Plugin.\n");
        sb.append(" */\n");

        // Annotations
        sb.append("@Generated(value = \"io.hexaglue.plugin.jpa\")\n");
        sb.append("@Component\n");
        sb.append("@Transactional\n");

        // Class declaration - implement all ports
        sb.append("public class ").append(adapterName).append(" implements ");
        for (int i = 0; i < ports.size(); i++) {
            if (i > 0) sb.append(", ");
            sb.append(ports.get(i).simpleName());
        }
        sb.append(" {\n\n");

        // Fields
        String repoField = decapitalize(repositoryName);
        String mapperField = decapitalize(mapperName);

        sb.append("    private final ")
                .append(repositoryName)
                .append(" ")
                .append(repoField)
                .append(";\n");
        sb.append("    private final ")
                .append(mapperName)
                .append(" ")
                .append(mapperField)
                .append(";\n\n");

        // Constructor
        sb.append("    /**\n");
        sb.append("     * Creates a new adapter with required dependencies.\n");
        sb.append("     *\n");
        sb.append("     * @param ").append(repoField).append(" the JPA repository\n");
        sb.append("     * @param ").append(mapperField).append(" the entity mapper\n");
        sb.append("     */\n");
        sb.append("    public ")
                .append(adapterName)
                .append("(")
                .append(repositoryName)
                .append(" ")
                .append(repoField)
                .append(", ")
                .append(mapperName)
                .append(" ")
                .append(mapperField)
                .append(") {\n");
        sb.append("        this.")
                .append(repoField)
                .append(" = ")
                .append(repoField)
                .append(";\n");
        sb.append("        this.")
                .append(mapperField)
                .append(" = ")
                .append(mapperField)
                .append(";\n");
        sb.append("    }\n\n");

        // Implement methods from all ports
        for (Port port : ports) {
            for (PortMethod method : port.methods()) {
                generatePortMethodImpl(sb, method, managedType, repoField, mapperField);
            }
        }

        sb.append("}\n");

        return sb.toString();
    }

    /**
     * Collects imports needed for a method's types.
     */
    private void collectMethodImports(PortMethod method, Set<String> imports) {
        String returnType = method.returnType();
        if (returnType != null) {
            if (returnType.contains("Optional") || returnType.equals("Optional")) {
                imports.add("java.util.Optional");
            }
            if (returnType.contains("List") || returnType.equals("List")) {
                imports.add("java.util.List");
            }
            if (returnType.contains("Set") || returnType.equals("Set")) {
                imports.add("java.util.Set");
            }
            if (returnType.contains("Collection") || returnType.equals("Collection")) {
                imports.add("java.util.Collection");
            }
            if (returnType.contains("Stream") || returnType.contains("stream.Stream")) {
                imports.add("java.util.stream.Stream");
            }
            if (returnType.contains("Page<") || returnType.contains("data.domain.Page")) {
                imports.add("org.springframework.data.domain.Page");
            }
        }

        // Add imports for parameter types
        for (String paramType : method.parameters()) {
            if (paramType != null && paramType.contains(".")) {
                if (paramType.contains("Pageable")) {
                    imports.add("org.springframework.data.domain.Pageable");
                } else if (paramType.contains("data.domain.Sort")) {
                    imports.add("org.springframework.data.domain.Sort");
                } else if (!paramType.startsWith("java.")) {
                    imports.add(paramType);
                }
            }
        }
    }

    /**
     * Generates an adapter class that implements a repository port.
     *
     * @param port the port interface to implement
     * @param managedType the domain type managed by this port
     * @return the generated adapter source code
     * @deprecated Use {@link #generateMergedAdapter(List, DomainType)} instead
     */
    @Deprecated
    String generateAdapter(Port port, DomainType managedType) {
        return generateMergedAdapter(List.of(port), managedType);
    }

    private void generatePortMethodImpl(
            StringBuilder sb, PortMethod method, DomainType managedType, String repoField, String mapperField) {

        String methodName = method.name();
        String rawReturnType = simplifyType(method.returnType());
        String domainName = managedType.simpleName();
        List<String> params = method.parameters();

        // Infer generic type parameters for common return types
        String returnType = inferFullReturnType(rawReturnType, methodName, domainName);

        sb.append("    @Override\n");
        sb.append("    public ")
                .append(returnType)
                .append(" ")
                .append(methodName)
                .append("(");

        // Parameters
        for (int i = 0; i < params.size(); i++) {
            if (i > 0) sb.append(", ");
            String paramType = simplifyType(params.get(i));
            sb.append(paramType).append(" param").append(i);
        }
        sb.append(") {\n");

        // Implementation based on method pattern
        String impl = generateMethodBody(methodName, returnType, params, domainName, repoField, mapperField);
        sb.append(impl);

        sb.append("    }\n\n");
    }

    private String generateMethodBody(
            String methodName,
            String returnType,
            List<String> params,
            String domainName,
            String repoField,
            String mapperField) {

        StringBuilder body = new StringBuilder();

        // Pattern matching for common repository methods
        if (methodName.equals("save") || methodName.equals("add") || methodName.equals("create")) {
            // save(Domain) -> Domain
            body.append("        var entity = ").append(mapperField).append(".toEntity(param0);\n");
            body.append("        var saved = ").append(repoField).append(".save(entity);\n");
            if (returnType.contains(domainName)) {
                body.append("        return ").append(mapperField).append(".toDomain(saved);\n");
            } else if (returnType.equals("void")) {
                // No return needed
            } else {
                body.append("        return ").append(mapperField).append(".toDomain(saved);\n");
            }

        } else if (methodName.equals("saveAll") || methodName.equals("updateAll")) {
            // saveAll(List<Domain>) -> List<Domain> or Iterable<Domain>
            body.append("        var entities = ").append(mapperField).append(".toEntityList(param0);\n");
            body.append("        var saved = ").append(repoField).append(".saveAll(entities);\n");
            body.append("        return ").append(mapperField).append(".toDomainList(saved);\n");

        } else if (methodName.equals("update")) {
            // update(Domain) -> Domain (same as save)
            body.append("        var entity = ").append(mapperField).append(".toEntity(param0);\n");
            body.append("        var saved = ").append(repoField).append(".save(entity);\n");
            if (returnType.contains(domainName)) {
                body.append("        return ").append(mapperField).append(".toDomain(saved);\n");
            } else if (returnType.equals("void")) {
                // No return needed
            } else {
                body.append("        return ").append(mapperField).append(".toDomain(saved);\n");
            }

        } else if (methodName.equals("findById") || methodName.equals("getById") || methodName.equals("get")) {
            // findById(Id) -> Domain or Optional<Domain>
            // Check if param is a wrapper type (e.g., OrderId) or a primitive type (e.g., UUID)
            String paramExpr = getIdParameterExpression("param0", params);
            body.append("        return ")
                    .append(repoField)
                    .append(".findById(")
                    .append(paramExpr)
                    .append(")\n");
            body.append("                .map(").append(mapperField).append("::toDomain)");
            // If return type is not Optional, extract the value
            if (!returnType.startsWith("Optional")) {
                body.append("\n                .orElse(null)");
            }
            body.append(";\n");

        } else if (methodName.equals("findAll") || methodName.equals("getAll") || methodName.equals("all")) {
            // Handle different parameter types for findAll
            if (params.isEmpty()) {
                // findAll() -> List<Domain>
                body.append("        return ")
                        .append(mapperField)
                        .append(".toDomainList(")
                        .append(repoField)
                        .append(".findAll());\n");
            } else if (hasPageableParameter(params)) {
                // findAll(Pageable) -> Page<Domain>
                body.append("        return ").append(repoField).append(".findAll(param0)\n");
                body.append("                .map(").append(mapperField).append("::toDomain);\n");
            } else if (hasSortParameter(params)) {
                // findAll(Sort) -> List<Domain>
                body.append("        return ")
                        .append(mapperField)
                        .append(".toDomainList(")
                        .append(repoField)
                        .append(".findAll(param0));\n");
            } else {
                // Unknown parameter pattern - generate TODO
                body.append("        // TODO: Implement findAll with custom parameters\n");
                body.append("        throw new UnsupportedOperationException(\"Not yet implemented\");\n");
            }

        } else if (methodName.equals("findAllAsStream")
                || methodName.equals("streamAll")
                || returnType.startsWith("Stream<")) {
            // findAllAsStream() -> Stream<Domain>
            body.append("        return ").append(repoField).append(".findAll().stream()\n");
            body.append("                .map(").append(mapperField).append("::toDomain);\n");

        } else if (methodName.equals("delete") || methodName.equals("remove")) {
            // delete(Domain) or delete(Id)
            if (params.size() == 1) {
                String paramType = simplifyType(params.get(0));
                if (isIdentityWrapperType(paramType)) {
                    // Wrapper type like OrderId
                    body.append("        ").append(repoField).append(".deleteById(param0.value());\n");
                } else if (isPrimitiveIdType(paramType)) {
                    // Primitive type like UUID, Long
                    body.append("        ").append(repoField).append(".deleteById(param0);\n");
                } else {
                    body.append("        var entity = ").append(mapperField).append(".toEntity(param0);\n");
                    body.append("        ").append(repoField).append(".delete(entity);\n");
                }
            }

        } else if (methodName.equals("deleteById") || methodName.equals("removeById")) {
            // deleteById(Id)
            String paramExpr = getIdParameterExpression("param0", params);
            body.append("        ")
                    .append(repoField)
                    .append(".deleteById(")
                    .append(paramExpr)
                    .append(");\n");

        } else if (methodName.equals("deleteAll") || methodName.equals("removeAll")) {
            // deleteAll() or deleteAll(List<Domain>)
            if (params.isEmpty()) {
                // deleteAll() - delete all entities
                body.append("        ").append(repoField).append(".deleteAll();\n");
            } else {
                // deleteAll(List<Domain>) - delete specific entities
                body.append("        ").append(repoField).append(".deleteAll(\n");
                body.append("                ").append(mapperField).append(".toEntityList(param0));\n");
            }

        } else if (methodName.equals("deleteAllById") || methodName.equals("removeAllById")) {
            // deleteAllById(List<Id>) - unwrap each wrapper ID
            body.append("        param0.stream()\n");
            body.append("                .map(id -> id.value())\n");
            body.append("                .forEach(").append(repoField).append("::deleteById);\n");

        } else if (methodName.equals("exists") || methodName.equals("existsById")) {
            // existsById(Id) -> boolean
            String paramExpr = getIdParameterExpression("param0", params);
            body.append("        return ")
                    .append(repoField)
                    .append(".existsById(")
                    .append(paramExpr)
                    .append(");\n");

        } else if (methodName.equals("count")) {
            // count() -> long
            body.append("        return ").append(repoField).append(".count();\n");

        } else if (methodName.startsWith("findBy")) {
            // Custom findBy method - delegate to repository
            body.append("        // TODO: Implement custom query or delegate to repository\n");
            body.append("        throw new UnsupportedOperationException(\"Not yet implemented\");\n");

        } else {
            // Unknown method - generate placeholder
            body.append("        // TODO: Implement this method\n");
            body.append("        throw new UnsupportedOperationException(\"Not yet implemented\");\n");
        }

        return body.toString();
    }

    /**
     * Infers the full return type with generics based on method name patterns.
     *
     * <p>Since annotation processing may lose generic information, we infer
     * common patterns like findById -> Optional<Domain>, findAll -> List<Domain>.
     */
    private String inferFullReturnType(String rawReturnType, String methodName, String domainName) {
        // If type already has generics, return as-is
        if (rawReturnType.contains("<")) {
            return rawReturnType;
        }

        // Infer based on method name and raw return type
        if (rawReturnType.equals("Optional")) {
            return "Optional<" + domainName + ">";
        }
        if (rawReturnType.equals("List")) {
            return "List<" + domainName + ">";
        }
        if (rawReturnType.equals("Set")) {
            return "Set<" + domainName + ">";
        }
        if (rawReturnType.equals("Collection")) {
            return "Collection<" + domainName + ">";
        }

        return rawReturnType;
    }

    private String simplifyType(String qualifiedName) {
        if (qualifiedName == null || qualifiedName.isEmpty()) {
            return "void";
        }

        // Handle generic types
        if (qualifiedName.contains("<")) {
            int genericStart = qualifiedName.indexOf('<');
            int genericEnd = qualifiedName.lastIndexOf('>');
            String baseType = simplifyType(qualifiedName.substring(0, genericStart));
            String genericType = simplifyType(qualifiedName.substring(genericStart + 1, genericEnd));
            return baseType + "<" + genericType + ">";
        }

        // Get simple name
        int lastDot = qualifiedName.lastIndexOf('.');
        return lastDot >= 0 ? qualifiedName.substring(lastDot + 1) : qualifiedName;
    }

    /**
     * Gets the expression for an ID parameter, handling both wrapper types and primitives.
     *
     * @param paramName the parameter variable name (e.g., "param0")
     * @param params the method parameter types
     * @return the expression to access the ID value
     */
    private String getIdParameterExpression(String paramName, List<String> params) {
        if (params.isEmpty()) {
            return paramName;
        }
        String paramType = simplifyType(params.get(0));
        if (isIdentityWrapperType(paramType)) {
            return paramName + ".value()";
        }
        return paramName;
    }

    /**
     * Checks if the type is a wrapper identity type (e.g., OrderId, CustomerId).
     */
    private boolean isIdentityWrapperType(String typeName) {
        return typeName.endsWith("Id") && !isPrimitiveIdType(typeName);
    }

    /**
     * Checks if the type is a primitive/standard ID type that doesn't need unwrapping.
     */
    private boolean isPrimitiveIdType(String typeName) {
        return switch (typeName) {
            case "UUID",
                    "Long",
                    "Integer",
                    "String",
                    "long",
                    "int",
                    "java.util.UUID",
                    "java.lang.Long",
                    "java.lang.Integer",
                    "java.lang.String" -> true;
            default -> false;
        };
    }

    private String decapitalize(String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }
        return Character.toLowerCase(str.charAt(0)) + str.substring(1);
    }

    /**
     * Checks if the method has a Pageable parameter.
     */
    private boolean hasPageableParameter(List<String> params) {
        return params.stream().anyMatch(p -> p != null && p.contains("Pageable"));
    }

    /**
     * Checks if the method has a Sort parameter.
     */
    private boolean hasSortParameter(List<String> params) {
        return params.stream().anyMatch(p -> p != null && p.contains("data.domain.Sort"));
    }
}
