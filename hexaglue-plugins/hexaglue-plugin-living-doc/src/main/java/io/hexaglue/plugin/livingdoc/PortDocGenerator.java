/*
 * This Source Code Form is part of the HexaGlue project.
 * Copyright (c) 2026 Scalastic
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 *
 * Commercial licensing options are available for organizations wishing
 * to use HexaGlue under terms different from the MPL 2.0.
 * Contact: info@hexaglue.io
 */

package io.hexaglue.plugin.livingdoc;

import io.hexaglue.spi.ir.IrSnapshot;
import io.hexaglue.spi.ir.Port;
import io.hexaglue.spi.ir.PortDirection;
import io.hexaglue.spi.ir.PortKind;
import io.hexaglue.spi.ir.PortMethod;
import java.util.List;

/**
 * Generates documentation for ports.
 */
final class PortDocGenerator {

    private final IrSnapshot ir;

    PortDocGenerator(IrSnapshot ir) {
        this.ir = ir;
    }

    String generate() {
        StringBuilder sb = new StringBuilder();

        // Title
        sb.append("# Ports\n\n");
        sb.append("*Generated by HexaGlue Living Documentation Plugin*\n\n");
        sb.append("[Back to Overview](README.md)\n\n");
        sb.append("---\n\n");

        // Introduction
        sb.append("## About Ports\n\n");
        sb.append("In hexagonal architecture, ports define the boundaries of the application:\n\n");
        sb.append("- **Driving Ports** (Primary/Inbound): Define how external actors interact with the application\n");
        sb.append(
                "- **Driven Ports** (Secondary/Outbound): Define how the application interacts with infrastructure\n\n");
        sb.append("---\n\n");

        // Table of contents
        generateTableOfContents(sb);

        // Driving Ports
        List<Port> drivingPorts = ir.ports().drivingPorts();
        if (!drivingPorts.isEmpty()) {
            sb.append("## Driving Ports (Primary)\n\n");
            sb.append("These ports are called by external actors (UI, API clients, etc.) ");
            sb.append("to trigger application behavior.\n\n");

            for (Port port : drivingPorts) {
                generatePortDocumentation(sb, port);
            }
        }

        // Driven Ports
        List<Port> drivenPorts = ir.ports().drivenPorts();
        if (!drivenPorts.isEmpty()) {
            sb.append("## Driven Ports (Secondary)\n\n");
            sb.append("These ports are called by the application to interact with external systems ");
            sb.append("(databases, external APIs, message queues, etc.).\n\n");

            for (Port port : drivenPorts) {
                generatePortDocumentation(sb, port);
            }
        }

        return sb.toString();
    }

    private void generateTableOfContents(StringBuilder sb) {
        sb.append("## Contents\n\n");

        List<Port> drivingPorts = ir.ports().drivingPorts();
        if (!drivingPorts.isEmpty()) {
            sb.append("### Driving Ports\n");
            for (Port port : drivingPorts) {
                sb.append("- [")
                        .append(port.simpleName())
                        .append("](#")
                        .append(toAnchor(port.simpleName()))
                        .append(")\n");
            }
            sb.append("\n");
        }

        List<Port> drivenPorts = ir.ports().drivenPorts();
        if (!drivenPorts.isEmpty()) {
            sb.append("### Driven Ports\n");
            for (Port port : drivenPorts) {
                sb.append("- [")
                        .append(port.simpleName())
                        .append("](#")
                        .append(toAnchor(port.simpleName()))
                        .append(")\n");
            }
            sb.append("\n");
        }

        sb.append("---\n\n");
    }

    private void generatePortDocumentation(StringBuilder sb, Port port) {
        // Port header
        sb.append("### ").append(port.simpleName()).append("\n\n");

        // Metadata table
        sb.append("| Property | Value |\n");
        sb.append("|----------|-------|\n");
        sb.append("| **Kind** | ").append(formatKind(port.kind())).append(" |\n");
        sb.append("| **Direction** | ")
                .append(formatDirection(port.direction()))
                .append(" |\n");
        sb.append("| **Package** | `").append(port.packageName()).append("` |\n");
        sb.append("| **Confidence** | ").append(port.confidence()).append(" |\n");
        sb.append("\n");

        // Managed types
        List<String> managedTypes = port.managedTypes();
        if (!managedTypes.isEmpty()) {
            sb.append("**Managed Domain Types**\n\n");
            for (String type : managedTypes) {
                String simpleName = type.substring(type.lastIndexOf('.') + 1);
                sb.append("- `").append(simpleName).append("`\n");
            }
            sb.append("\n");
        }

        // Methods
        List<PortMethod> methods = port.methods();
        if (!methods.isEmpty()) {
            sb.append("**Methods**\n\n");
            sb.append("| Method | Return Type | Parameters |\n");
            sb.append("|--------|-------------|------------|\n");
            for (PortMethod method : methods) {
                sb.append("| `")
                        .append(method.name())
                        .append("` | `")
                        .append(simplifyType(method.returnType()))
                        .append("` | ")
                        .append(formatParameters(method.parameters()))
                        .append(" |\n");
            }
            sb.append("\n");

            // Method details
            sb.append("<details>\n");
            sb.append("<summary>Method Signatures</summary>\n\n");
            sb.append("```java\n");
            sb.append("public interface ").append(port.simpleName()).append(" {\n");
            for (PortMethod method : methods) {
                sb.append("    ")
                        .append(simplifyType(method.returnType()))
                        .append(" ")
                        .append(method.name())
                        .append("(")
                        .append(formatMethodParams(method.parameters()))
                        .append(");\n");
            }
            sb.append("}\n");
            sb.append("```\n\n");
            sb.append("</details>\n\n");
        }

        // Debug information
        sb.append("<details>\n");
        sb.append("<summary>Debug Information</summary>\n\n");
        sb.append("| Property | Value |\n");
        sb.append("|----------|-------|\n");
        sb.append("| **Qualified Name** | `").append(port.qualifiedName()).append("` |\n");

        // Annotations
        List<String> annotations = port.annotations();
        if (!annotations.isEmpty()) {
            sb.append("| **Annotations** | ");
            for (int i = 0; i < annotations.size(); i++) {
                if (i > 0) sb.append(", ");
                sb.append("`@").append(simplifyType(annotations.get(i))).append("`");
            }
            sb.append(" |\n");
        } else {
            sb.append("| **Annotations** | *none* |\n");
        }

        // Source reference
        if (port.sourceRef() != null && port.sourceRef().isReal()) {
            sb.append("| **Source File** | `").append(port.sourceRef().filePath()).append("` |\n");
            sb.append("| **Line** | ").append(port.sourceRef().lineStart()).append(" |\n");
        }

        // Managed types (full qualified names)
        if (!managedTypes.isEmpty()) {
            sb.append("| **Managed Types (FQN)** | ");
            for (int i = 0; i < managedTypes.size(); i++) {
                if (i > 0) sb.append(", ");
                sb.append("`").append(managedTypes.get(i)).append("`");
            }
            sb.append(" |\n");
        }

        sb.append("\n</details>\n\n");

        sb.append("---\n\n");
    }

    private String formatKind(PortKind kind) {
        return switch (kind) {
            case REPOSITORY -> "Repository";
            case GATEWAY -> "Gateway";
            case USE_CASE -> "Use Case";
            case COMMAND -> "Command Handler";
            case QUERY -> "Query Handler";
            case EVENT_PUBLISHER -> "Event Publisher";
            case GENERIC -> "Generic Port";
        };
    }

    private String formatDirection(PortDirection direction) {
        return switch (direction) {
            case DRIVING -> "Driving (Primary/Inbound)";
            case DRIVEN -> "Driven (Secondary/Outbound)";
        };
    }

    private String simplifyType(String qualifiedType) {
        if (qualifiedType == null || qualifiedType.isEmpty()) {
            return "void";
        }
        // Handle generics like Optional<Order>
        if (qualifiedType.contains("<")) {
            int start = qualifiedType.lastIndexOf('.', qualifiedType.indexOf('<'));
            String outer = start >= 0 ? qualifiedType.substring(start + 1) : qualifiedType;
            return outer;
        }
        int lastDot = qualifiedType.lastIndexOf('.');
        return lastDot >= 0 ? qualifiedType.substring(lastDot + 1) : qualifiedType;
    }

    private String formatParameters(List<String> parameters) {
        if (parameters.isEmpty()) {
            return "-";
        }
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < parameters.size(); i++) {
            if (i > 0) sb.append(", ");
            sb.append("`").append(simplifyType(parameters.get(i))).append("`");
        }
        return sb.toString();
    }

    private String formatMethodParams(List<String> parameters) {
        if (parameters.isEmpty()) {
            return "";
        }
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < parameters.size(); i++) {
            if (i > 0) sb.append(", ");
            sb.append(simplifyType(parameters.get(i))).append(" arg").append(i);
        }
        return sb.toString();
    }

    private String toAnchor(String text) {
        return text.toLowerCase().replaceAll("[^a-z0-9]+", "-");
    }
}
