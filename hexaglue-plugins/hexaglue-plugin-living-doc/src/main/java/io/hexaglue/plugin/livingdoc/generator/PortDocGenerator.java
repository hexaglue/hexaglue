/*
 * This Source Code Form is part of the HexaGlue project.
 * Copyright (c) 2026 Scalastic
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 *
 * Commercial licensing options are available for organizations wishing
 * to use HexaGlue under terms different from the MPL 2.0.
 * Contact: info@hexaglue.io
 */

package io.hexaglue.plugin.livingdoc.generator;

import io.hexaglue.arch.ArchitecturalModel;
import io.hexaglue.plugin.livingdoc.content.PortContentSelector;
import io.hexaglue.plugin.livingdoc.markdown.MarkdownBuilder;
import io.hexaglue.plugin.livingdoc.model.PortDoc;
import io.hexaglue.plugin.livingdoc.renderer.PortRenderer;
import io.hexaglue.plugin.livingdoc.util.MarkdownUtil;
import io.hexaglue.spi.ir.IrSnapshot;
import java.util.List;

/**
 * Generates documentation for ports.
 *
 * <p>Uses three-layer architecture:
 * <ol>
 *   <li>ContentSelector - selects and transforms IR data to documentation models</li>
 *   <li>DocumentationModel - immutable records representing documentation content</li>
 *   <li>Renderer - renders documentation models to Markdown</li>
 * </ol>
 *
 * <p>Supports both legacy SPI (IrSnapshot) and v4 model (ArchitecturalModel).
 *
 * @since 3.0.0
 */
public final class PortDocGenerator {

    private final PortContentSelector contentSelector;
    private final PortRenderer renderer;

    /**
     * Creates a generator using legacy IrSnapshot.
     *
     * @param ir the IR snapshot
     * @deprecated Use {@link #PortDocGenerator(ArchitecturalModel)} for v4 model support
     */
    @Deprecated(since = "4.0.0", forRemoval = true)
    public PortDocGenerator(IrSnapshot ir) {
        this.contentSelector = new PortContentSelector(ir);
        this.renderer = new PortRenderer();
    }

    /**
     * Creates a generator using v4 ArchitecturalModel.
     *
     * @param model the architectural model
     * @since 4.0.0
     */
    public PortDocGenerator(ArchitecturalModel model) {
        this.contentSelector = new PortContentSelector(model);
        this.renderer = new PortRenderer();
    }

    public String generate() {
        MarkdownBuilder md = new MarkdownBuilder()
                .h1("Ports")
                .paragraph("*Generated by HexaGlue Living Documentation Plugin*")
                .link("Back to Overview", "README.md")
                .newline()
                .newline()
                .horizontalRule();

        // Introduction
        md.h2("About Ports")
                .paragraph("In hexagonal architecture, ports define the boundaries of the application:")
                .newline()
                .bulletItem(
                        "**Driving Ports** (Primary/Inbound): Define how external actors interact with the application")
                .bulletItem(
                        "**Driven Ports** (Secondary/Outbound): Define how the application interacts with infrastructure")
                .newline()
                .horizontalRule();

        // Table of contents
        generateTableOfContents(md);

        // Driving Ports
        List<PortDoc> drivingPorts = contentSelector.selectDrivingPorts();
        if (!drivingPorts.isEmpty()) {
            md.h2("Driving Ports (Primary)")
                    .paragraph(
                            "These ports are called by external actors (UI, API clients, etc.) to trigger application behavior.");

            for (PortDoc port : drivingPorts) {
                md.raw(renderer.renderPort(port));
            }
        }

        // Driven Ports
        List<PortDoc> drivenPorts = contentSelector.selectDrivenPorts();
        if (!drivenPorts.isEmpty()) {
            md.h2("Driven Ports (Secondary)")
                    .paragraph(
                            "These ports are called by the application to interact with external systems (databases, external APIs, message queues, etc.).");

            for (PortDoc port : drivenPorts) {
                md.raw(renderer.renderPort(port));
            }
        }

        return md.build();
    }

    private void generateTableOfContents(MarkdownBuilder md) {
        md.h2("Contents");

        addTocSection(md, "Driving Ports", contentSelector.selectDrivingPorts());
        addTocSection(md, "Driven Ports", contentSelector.selectDrivenPorts());

        md.horizontalRule();
    }

    private void addTocSection(MarkdownBuilder md, String title, List<PortDoc> ports) {
        if (!ports.isEmpty()) {
            md.h3(title);
            for (PortDoc port : ports) {
                md.bulletItem("[" + port.name() + "](#" + MarkdownUtil.toAnchor(port.name()) + ")");
            }
            md.newline();
        }
    }
}
