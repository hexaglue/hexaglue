/*
 * This Source Code Form is part of the HexaGlue project.
 * Copyright (c) 2026 Scalastic
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 *
 * Commercial licensing options are available for organizations wishing
 * to use HexaGlue under terms different from the MPL 2.0.
 * Contact: info@hexaglue.io
 */

package io.hexaglue.plugin.livingdoc.generator;

import io.hexaglue.arch.ArchitecturalModel;
import io.hexaglue.plugin.livingdoc.content.DomainContentSelector;
import io.hexaglue.plugin.livingdoc.markdown.MarkdownBuilder;
import io.hexaglue.plugin.livingdoc.model.DomainTypeDoc;
import io.hexaglue.plugin.livingdoc.renderer.DomainRenderer;
import io.hexaglue.plugin.livingdoc.util.MarkdownUtil;
import io.hexaglue.spi.ir.IrSnapshot;
import java.util.List;

/**
 * Generates documentation for the domain model.
 *
 * <p>Uses three-layer architecture:
 * <ol>
 *   <li>ContentSelector - selects and transforms IR data to documentation models</li>
 *   <li>DocumentationModel - immutable records representing documentation content</li>
 *   <li>Renderer - renders documentation models to Markdown</li>
 * </ol>
 *
 * <p>Supports both legacy SPI (IrSnapshot) and v4 model (ArchitecturalModel).
 *
 * @since 3.0.0
 */
public final class DomainDocGenerator {

    private final DomainContentSelector contentSelector;
    private final DomainRenderer renderer;

    /**
     * Creates a generator using legacy IrSnapshot.
     *
     * @param ir the IR snapshot
     * @deprecated Use {@link #DomainDocGenerator(ArchitecturalModel)} for v4 model support
     */
    @Deprecated(since = "4.0.0", forRemoval = true)
    public DomainDocGenerator(IrSnapshot ir) {
        this.contentSelector = new DomainContentSelector(ir);
        this.renderer = new DomainRenderer();
    }

    /**
     * Creates a generator using v4 ArchitecturalModel.
     *
     * @param model the architectural model
     * @since 4.0.0
     */
    public DomainDocGenerator(ArchitecturalModel model) {
        this.contentSelector = new DomainContentSelector(model);
        this.renderer = new DomainRenderer();
    }

    public String generate() {
        MarkdownBuilder md = new MarkdownBuilder()
                .h1("Domain Model")
                .paragraph("*Generated by HexaGlue Living Documentation Plugin*")
                .link("Back to Overview", "README.md")
                .newline()
                .newline()
                .horizontalRule();

        // Table of contents
        generateTableOfContents(md);

        // Aggregate Roots
        List<DomainTypeDoc> aggregates = contentSelector.selectAggregateRoots();
        if (!aggregates.isEmpty()) {
            md.h2("Aggregate Roots")
                    .paragraph(
                            "Aggregate roots are the entry points to aggregates. They ensure consistency boundaries and manage their own invariants.");
            for (DomainTypeDoc agg : aggregates) {
                md.raw(renderer.renderType(agg));
            }
        }

        // Entities
        List<DomainTypeDoc> entities = contentSelector.selectEntities();
        if (!entities.isEmpty()) {
            md.h2("Entities").paragraph("Entities have identity and are accessed through their aggregate root.");
            for (DomainTypeDoc entity : entities) {
                md.raw(renderer.renderType(entity));
            }
        }

        // Value Objects
        List<DomainTypeDoc> valueObjects = contentSelector.selectValueObjects();
        if (!valueObjects.isEmpty()) {
            md.h2("Value Objects")
                    .paragraph("Value objects are immutable and defined by their attributes, not identity.");
            for (DomainTypeDoc vo : valueObjects) {
                md.raw(renderer.renderType(vo));
            }
        }

        // Identifiers
        List<DomainTypeDoc> identifiers = contentSelector.selectIdentifiers();
        if (!identifiers.isEmpty()) {
            md.h2("Identifiers").paragraph("Identifier types wrap primitive identity values for type safety.");
            for (DomainTypeDoc id : identifiers) {
                md.raw(renderer.renderType(id));
            }
        }

        // Domain Events
        List<DomainTypeDoc> events = contentSelector.selectDomainEvents();
        if (!events.isEmpty()) {
            md.h2("Domain Events")
                    .paragraph("Domain events represent something meaningful that happened in the domain.");
            for (DomainTypeDoc event : events) {
                md.raw(renderer.renderType(event));
            }
        }

        // Domain Services
        List<DomainTypeDoc> domainServices = contentSelector.selectDomainServices();
        if (!domainServices.isEmpty()) {
            md.h2("Domain Services")
                    .paragraph(
                            "Domain services contain domain logic that doesn't belong to entities. They have NO dependencies on infrastructure ports.");
            for (DomainTypeDoc service : domainServices) {
                md.raw(renderer.renderType(service));
            }
        }

        // Application Services
        List<DomainTypeDoc> appServices = contentSelector.selectApplicationServices();
        if (!appServices.isEmpty()) {
            md.h2("Application Services")
                    .paragraph(
                            "Application services orchestrate use cases by coordinating domain logic and infrastructure through ports. They have dependencies on DRIVEN ports.");
            for (DomainTypeDoc service : appServices) {
                md.raw(renderer.renderType(service));
            }
        }

        return md.build();
    }

    private void generateTableOfContents(MarkdownBuilder md) {
        md.h2("Contents");

        addTocSection(md, "Aggregate Roots", contentSelector.selectAggregateRoots());
        addTocSection(md, "Entities", contentSelector.selectEntities());
        addTocSection(md, "Value Objects", contentSelector.selectValueObjects());
        addTocSection(md, "Identifiers", contentSelector.selectIdentifiers());
        addTocSection(md, "Domain Events", contentSelector.selectDomainEvents());
        addTocSection(md, "Domain Services", contentSelector.selectDomainServices());
        addTocSection(md, "Application Services", contentSelector.selectApplicationServices());

        md.horizontalRule();
    }

    private void addTocSection(MarkdownBuilder md, String title, List<DomainTypeDoc> types) {
        if (!types.isEmpty()) {
            md.h3(title);
            for (DomainTypeDoc type : types) {
                md.bulletItem("[" + type.name() + "](#" + MarkdownUtil.toAnchor(type.name()) + ")");
            }
            md.newline();
        }
    }
}
