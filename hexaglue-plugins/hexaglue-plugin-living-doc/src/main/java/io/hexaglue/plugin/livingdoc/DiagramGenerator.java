/*
 * This Source Code Form is part of the HexaGlue project.
 * Copyright (c) 2026 Scalastic
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 *
 * Commercial licensing options are available for organizations wishing
 * to use HexaGlue under terms different from the MPL 2.0.
 * Contact: info@hexaglue.io
 */

package io.hexaglue.plugin.livingdoc;

import io.hexaglue.spi.ir.DomainKind;
import io.hexaglue.spi.ir.DomainProperty;
import io.hexaglue.spi.ir.DomainRelation;
import io.hexaglue.spi.ir.DomainType;
import io.hexaglue.spi.ir.IrSnapshot;
import io.hexaglue.spi.ir.Port;
import io.hexaglue.spi.ir.RelationKind;
import java.util.List;

/**
 * Generates Mermaid diagrams for the architecture.
 */
final class DiagramGenerator {

    private final IrSnapshot ir;

    DiagramGenerator(IrSnapshot ir) {
        this.ir = ir;
    }

    String generate() {
        StringBuilder sb = new StringBuilder();

        // Title
        sb.append("# Architecture Diagrams\n\n");
        sb.append("*Generated by HexaGlue Living Documentation Plugin*\n\n");
        sb.append("[Back to Overview](README.md)\n\n");
        sb.append("---\n\n");

        // Domain Model Class Diagram
        generateDomainClassDiagram(sb);

        // Aggregate Diagrams
        generateAggregateDiagrams(sb);

        // Ports Flow Diagram
        generatePortsFlowDiagram(sb);

        return sb.toString();
    }

    private void generateDomainClassDiagram(StringBuilder sb) {
        sb.append("## Domain Model\n\n");
        sb.append("Class diagram showing domain types and their relationships.\n\n");

        sb.append("```mermaid\n");
        sb.append("classDiagram\n");

        // Generate classes
        for (DomainType type : ir.domain().types()) {
            generateClassDefinition(sb, type);
        }

        // Generate relationships
        for (DomainType type : ir.domain().types()) {
            generateRelationships(sb, type);
        }

        sb.append("```\n\n");
    }

    private void generateClassDefinition(StringBuilder sb, DomainType type) {
        String className = sanitizeId(type.simpleName());

        // Class declaration with stereotype
        sb.append("    class ").append(className).append(" {\n");

        // Stereotype annotation
        String stereotype = getStereotype(type.kind());
        if (stereotype != null) {
            sb.append("        <<").append(stereotype).append(">>\n");
        }

        // Identity field
        type.identity().ifPresent(id -> {
            sb.append("        +")
                    .append(id.type().simpleName())
                    .append(" ")
                    .append(id.fieldName())
                    .append("\n");
        });

        // Properties (limit to avoid cluttering)
        List<DomainProperty> props = type.properties();
        int maxProps = Math.min(props.size(), 5);
        for (int i = 0; i < maxProps; i++) {
            DomainProperty prop = props.get(i);
            if (!prop.isIdentity()) {
                String propType = prop.type().isCollectionLike()
                        ? "List~" + prop.type().unwrapElement().simpleName() + "~"
                        : prop.type().simpleName();
                sb.append("        +")
                        .append(propType)
                        .append(" ")
                        .append(prop.name())
                        .append("\n");
            }
        }
        if (props.size() > maxProps) {
            sb.append("        ...\n");
        }

        sb.append("    }\n");
    }

    private void generateRelationships(StringBuilder sb, DomainType type) {
        String sourceClass = sanitizeId(type.simpleName());

        // From explicit relations
        for (DomainRelation rel : type.relations()) {
            String targetClass = sanitizeId(rel.targetSimpleName());

            String arrow = getRelationArrow(rel.kind());
            sb.append("    ")
                    .append(sourceClass)
                    .append(" ")
                    .append(arrow)
                    .append(" ")
                    .append(targetClass)
                    .append("\n");
        }

        // From properties referencing other domain types
        for (DomainProperty prop : type.properties()) {
            if (!prop.isIdentity() && !prop.hasRelation()) {
                String propTypeName = prop.type().unwrapElement().qualifiedName();
                ir.domain().findByQualifiedName(propTypeName).ifPresent(targetType -> {
                    String targetClass = sanitizeId(targetType.simpleName());
                    if (!sourceClass.equals(targetClass)) {
                        if (prop.type().isCollectionLike()) {
                            sb.append("    ")
                                    .append(sourceClass)
                                    .append(" \"1\" --o \"*\" ")
                                    .append(targetClass)
                                    .append(" : ")
                                    .append(prop.name())
                                    .append("\n");
                        } else {
                            sb.append("    ")
                                    .append(sourceClass)
                                    .append(" --> ")
                                    .append(targetClass)
                                    .append(" : ")
                                    .append(prop.name())
                                    .append("\n");
                        }
                    }
                });
            }
        }
    }

    private void generateAggregateDiagrams(StringBuilder sb) {
        List<DomainType> aggregates = ir.domain().aggregateRoots();
        if (aggregates.isEmpty()) {
            return;
        }

        sb.append("## Aggregates\n\n");
        sb.append("Each aggregate root with its entities and value objects.\n\n");

        for (DomainType aggregate : aggregates) {
            sb.append("### ").append(aggregate.simpleName()).append(" Aggregate\n\n");
            sb.append("```mermaid\n");
            sb.append("classDiagram\n");

            // The aggregate root
            generateClassDefinition(sb, aggregate);

            // Related types from properties
            for (DomainProperty prop : aggregate.properties()) {
                String propTypeName = prop.type().unwrapElement().qualifiedName();
                ir.domain().findByQualifiedName(propTypeName).ifPresent(relatedType -> {
                    generateClassDefinition(sb, relatedType);

                    String sourceClass = sanitizeId(aggregate.simpleName());
                    String targetClass = sanitizeId(relatedType.simpleName());
                    if (prop.type().isCollectionLike()) {
                        sb.append("    ")
                                .append(sourceClass)
                                .append(" \"1\" *-- \"*\" ")
                                .append(targetClass)
                                .append("\n");
                    } else {
                        sb.append("    ")
                                .append(sourceClass)
                                .append(" *-- ")
                                .append(targetClass)
                                .append("\n");
                    }
                });
            }

            sb.append("```\n\n");
        }
    }

    private void generatePortsFlowDiagram(StringBuilder sb) {
        sb.append("## Port Interactions\n\n");
        sb.append("Flow of interactions through the hexagonal architecture.\n\n");

        sb.append("```mermaid\n");
        sb.append("flowchart LR\n");

        // External actors
        sb.append("    subgraph External[\"External\"]\n");
        sb.append("        User([User])\n");
        sb.append("        API([API Client])\n");
        sb.append("    end\n\n");

        // Driving ports
        List<Port> drivingPorts = ir.ports().drivingPorts();
        if (!drivingPorts.isEmpty()) {
            sb.append("    subgraph Driving[\"Driving Ports\"]\n");
            for (Port port : drivingPorts) {
                sb.append("        ")
                        .append(sanitizeId(port.simpleName()))
                        .append("[")
                        .append(port.simpleName())
                        .append("]\n");
            }
            sb.append("    end\n\n");
        }

        // Domain
        List<DomainType> aggregates = ir.domain().aggregateRoots();
        sb.append("    subgraph Domain[\"Domain\"]\n");
        if (aggregates.isEmpty()) {
            sb.append("        DomainLogic[Domain Logic]\n");
        } else {
            for (DomainType agg : aggregates) {
                sb.append("        ")
                        .append(sanitizeId(agg.simpleName()))
                        .append("{{")
                        .append(agg.simpleName())
                        .append("}}\n");
            }
        }
        sb.append("    end\n\n");

        // Driven ports
        List<Port> drivenPorts = ir.ports().drivenPorts();
        if (!drivenPorts.isEmpty()) {
            sb.append("    subgraph Driven[\"Driven Ports\"]\n");
            for (Port port : drivenPorts) {
                sb.append("        ")
                        .append(sanitizeId(port.simpleName()))
                        .append("[")
                        .append(port.simpleName())
                        .append("]\n");
            }
            sb.append("    end\n\n");
        }

        // Infrastructure
        sb.append("    subgraph Infra[\"Infrastructure\"]\n");
        sb.append("        DB[(Database)]\n");
        sb.append("        ExtAPI[External APIs]\n");
        sb.append("    end\n\n");

        // Connections
        sb.append("    User --> Driving\n");
        sb.append("    API --> Driving\n");
        sb.append("    Driving --> Domain\n");
        sb.append("    Domain --> Driven\n");
        sb.append("    Driven --> DB\n");
        sb.append("    Driven --> ExtAPI\n");

        sb.append("```\n\n");
    }

    private String getStereotype(DomainKind kind) {
        return switch (kind) {
            case AGGREGATE_ROOT -> "Aggregate Root";
            case ENTITY -> "Entity";
            case VALUE_OBJECT -> "Value Object";
            case IDENTIFIER -> "Identifier";
            case DOMAIN_EVENT -> "Event";
            case DOMAIN_SERVICE -> "Service";
        };
    }

    private String getRelationArrow(RelationKind kind) {
        return switch (kind) {
            case ONE_TO_ONE -> "\"1\" -- \"1\"";
            case ONE_TO_MANY -> "\"1\" --o \"*\"";
            case MANY_TO_ONE -> "\"*\" o-- \"1\"";
            case MANY_TO_MANY -> "\"*\" --o \"*\"";
            case EMBEDDED -> "*--";
            case ELEMENT_COLLECTION -> "\"1\" *-- \"*\"";
        };
    }

    private String sanitizeId(String name) {
        return name.replaceAll("[^a-zA-Z0-9]", "_");
    }
}
