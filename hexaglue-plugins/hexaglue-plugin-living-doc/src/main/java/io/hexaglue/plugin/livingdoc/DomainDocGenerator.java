package io.hexaglue.plugin.livingdoc;

import io.hexaglue.spi.ir.Cardinality;
import io.hexaglue.spi.ir.DomainKind;
import io.hexaglue.spi.ir.DomainProperty;
import io.hexaglue.spi.ir.DomainRelation;
import io.hexaglue.spi.ir.DomainType;
import io.hexaglue.spi.ir.Identity;
import io.hexaglue.spi.ir.IrSnapshot;
import java.util.List;

/**
 * Generates documentation for the domain model.
 */
final class DomainDocGenerator {

    private final IrSnapshot ir;

    DomainDocGenerator(IrSnapshot ir) {
        this.ir = ir;
    }

    String generate() {
        StringBuilder sb = new StringBuilder();

        // Title
        sb.append("# Domain Model\n\n");
        sb.append("*Generated by HexaGlue Living Documentation Plugin*\n\n");
        sb.append("[Back to Overview](README.md)\n\n");
        sb.append("---\n\n");

        // Table of contents
        generateTableOfContents(sb);

        // Aggregate Roots
        List<DomainType> aggregates = ir.domain().aggregateRoots();
        if (!aggregates.isEmpty()) {
            sb.append("## Aggregate Roots\n\n");
            sb.append("Aggregate roots are the entry points to aggregates. ");
            sb.append("They ensure consistency boundaries and manage their own invariants.\n\n");
            for (DomainType agg : aggregates) {
                generateTypeDocumentation(sb, agg);
            }
        }

        // Entities
        List<DomainType> entities = ir.domain().typesOfKind(DomainKind.ENTITY);
        if (!entities.isEmpty()) {
            sb.append("## Entities\n\n");
            sb.append("Entities have identity and are accessed through their aggregate root.\n\n");
            for (DomainType entity : entities) {
                generateTypeDocumentation(sb, entity);
            }
        }

        // Value Objects
        List<DomainType> valueObjects = ir.domain().valueObjects();
        if (!valueObjects.isEmpty()) {
            sb.append("## Value Objects\n\n");
            sb.append("Value objects are immutable and defined by their attributes, not identity.\n\n");
            for (DomainType vo : valueObjects) {
                generateTypeDocumentation(sb, vo);
            }
        }

        // Identifiers
        List<DomainType> identifiers = ir.domain().typesOfKind(DomainKind.IDENTIFIER);
        if (!identifiers.isEmpty()) {
            sb.append("## Identifiers\n\n");
            sb.append("Identifier types wrap primitive identity values for type safety.\n\n");
            for (DomainType id : identifiers) {
                generateTypeDocumentation(sb, id);
            }
        }

        // Domain Events
        List<DomainType> events = ir.domain().typesOfKind(DomainKind.DOMAIN_EVENT);
        if (!events.isEmpty()) {
            sb.append("## Domain Events\n\n");
            sb.append("Domain events represent something meaningful that happened in the domain.\n\n");
            for (DomainType event : events) {
                generateTypeDocumentation(sb, event);
            }
        }

        // Domain Services
        List<DomainType> services = ir.domain().typesOfKind(DomainKind.DOMAIN_SERVICE);
        if (!services.isEmpty()) {
            sb.append("## Domain Services\n\n");
            sb.append("Domain services contain domain logic that doesn't belong to entities.\n\n");
            for (DomainType service : services) {
                generateTypeDocumentation(sb, service);
            }
        }

        return sb.toString();
    }

    private void generateTableOfContents(StringBuilder sb) {
        sb.append("## Contents\n\n");

        List<DomainType> aggregates = ir.domain().aggregateRoots();
        if (!aggregates.isEmpty()) {
            sb.append("### Aggregate Roots\n");
            for (DomainType agg : aggregates) {
                sb.append("- [")
                        .append(agg.simpleName())
                        .append("](#")
                        .append(toAnchor(agg.simpleName()))
                        .append(")\n");
            }
            sb.append("\n");
        }

        List<DomainType> entities = ir.domain().typesOfKind(DomainKind.ENTITY);
        if (!entities.isEmpty()) {
            sb.append("### Entities\n");
            for (DomainType entity : entities) {
                sb.append("- [")
                        .append(entity.simpleName())
                        .append("](#")
                        .append(toAnchor(entity.simpleName()))
                        .append(")\n");
            }
            sb.append("\n");
        }

        List<DomainType> valueObjects = ir.domain().valueObjects();
        if (!valueObjects.isEmpty()) {
            sb.append("### Value Objects\n");
            for (DomainType vo : valueObjects) {
                sb.append("- [")
                        .append(vo.simpleName())
                        .append("](#")
                        .append(toAnchor(vo.simpleName()))
                        .append(")\n");
            }
            sb.append("\n");
        }

        sb.append("---\n\n");
    }

    private void generateTypeDocumentation(StringBuilder sb, DomainType type) {
        // Type header
        sb.append("### ").append(type.simpleName()).append("\n\n");

        // Metadata table
        sb.append("| Property | Value |\n");
        sb.append("|----------|-------|\n");
        sb.append("| **Kind** | ").append(formatKind(type.kind())).append(" |\n");
        sb.append("| **Package** | `").append(type.packageName()).append("` |\n");
        sb.append("| **Type** | ").append(type.construct()).append(" |\n");
        sb.append("| **Confidence** | ").append(type.confidence()).append(" |\n");
        sb.append("\n");

        // Identity
        if (type.hasIdentity()) {
            Identity id = type.identity().get();
            sb.append("**Identity**\n\n");
            sb.append("| Field | Type | Underlying | Strategy |\n");
            sb.append("|-------|------|------------|----------|\n");
            sb.append("| `")
                    .append(id.fieldName())
                    .append("` | `")
                    .append(id.type().simpleName())
                    .append("` | `")
                    .append(id.unwrappedType().simpleName())
                    .append("` | ")
                    .append(id.strategy())
                    .append(" |\n\n");
        }

        // Properties
        List<DomainProperty> properties = type.properties();
        if (!properties.isEmpty()) {
            sb.append("**Properties**\n\n");
            sb.append("| Name | Type | Cardinality | Notes |\n");
            sb.append("|------|------|-------------|-------|\n");
            for (DomainProperty prop : properties) {
                sb.append("| `")
                        .append(prop.name())
                        .append("` | `")
                        .append(formatPropertyType(prop))
                        .append("` | ")
                        .append(formatCardinality(prop.cardinality()))
                        .append(" | ")
                        .append(formatPropertyNotes(prop))
                        .append(" |\n");
            }
            sb.append("\n");
        }

        // Relations
        List<DomainRelation> relations = type.relations();
        if (!relations.isEmpty()) {
            sb.append("**Relationships**\n\n");
            sb.append("| Target | Kind | Direction |\n");
            sb.append("|--------|------|----------|\n");
            for (DomainRelation rel : relations) {
                sb.append("| `")
                        .append(rel.targetSimpleName())
                        .append("` | ")
                        .append(rel.kind())
                        .append(" | ")
                        .append(rel.isOwning() ? "Owning" : "Inverse")
                        .append(" |\n");
            }
            sb.append("\n");
        }

        sb.append("---\n\n");
    }

    private String formatKind(DomainKind kind) {
        return switch (kind) {
            case AGGREGATE_ROOT -> "Aggregate Root";
            case ENTITY -> "Entity";
            case VALUE_OBJECT -> "Value Object";
            case IDENTIFIER -> "Identifier";
            case DOMAIN_EVENT -> "Domain Event";
            case DOMAIN_SERVICE -> "Domain Service";
        };
    }

    private String formatPropertyType(DomainProperty prop) {
        if (prop.type().isCollectionLike()) {
            return prop.type().simpleName() + "<" + prop.type().unwrapElement().simpleName() + ">";
        } else if (prop.type().isOptionalLike()) {
            return "Optional<" + prop.type().unwrapElement().simpleName() + ">";
        }
        return prop.type().simpleName();
    }

    private String formatCardinality(Cardinality cardinality) {
        return switch (cardinality) {
            case SINGLE -> "Single";
            case OPTIONAL -> "Optional";
            case COLLECTION -> "Collection";
        };
    }

    private String formatPropertyNotes(DomainProperty prop) {
        StringBuilder notes = new StringBuilder();
        if (prop.isIdentity()) {
            notes.append("Identity");
        }
        if (prop.isEmbedded()) {
            if (!notes.isEmpty()) notes.append(", ");
            notes.append("Embedded");
        }
        if (prop.hasRelation()) {
            if (!notes.isEmpty()) notes.append(", ");
            notes.append("Relation");
        }
        return notes.isEmpty() ? "-" : notes.toString();
    }

    private String toAnchor(String text) {
        return text.toLowerCase().replaceAll("[^a-z0-9]+", "-");
    }
}
