/*
 * This Source Code Form is part of the HexaGlue project.
 * Copyright (c) 2026 Scalastic
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 *
 * Commercial licensing options are available for organizations wishing
 * to use HexaGlue under terms different from the MPL 2.0.
 * Contact: info@hexaglue.io
 */

package io.hexaglue.plugin.livingdoc;

import io.hexaglue.spi.ir.Cardinality;
import io.hexaglue.spi.ir.DomainKind;
import io.hexaglue.spi.ir.DomainProperty;
import io.hexaglue.spi.ir.DomainRelation;
import io.hexaglue.spi.ir.DomainType;
import io.hexaglue.spi.ir.Identity;
import io.hexaglue.spi.ir.IrSnapshot;
import java.util.List;

/**
 * Generates documentation for the domain model.
 */
final class DomainDocGenerator {

    private final IrSnapshot ir;

    DomainDocGenerator(IrSnapshot ir) {
        this.ir = ir;
    }

    String generate() {
        StringBuilder sb = new StringBuilder();

        // Title
        sb.append("# Domain Model\n\n");
        sb.append("*Generated by HexaGlue Living Documentation Plugin*\n\n");
        sb.append("[Back to Overview](README.md)\n\n");
        sb.append("---\n\n");

        // Table of contents
        generateTableOfContents(sb);

        // Aggregate Roots
        List<DomainType> aggregates = ir.domain().aggregateRoots();
        if (!aggregates.isEmpty()) {
            sb.append("## Aggregate Roots\n\n");
            sb.append("Aggregate roots are the entry points to aggregates. ");
            sb.append("They ensure consistency boundaries and manage their own invariants.\n\n");
            for (DomainType agg : aggregates) {
                generateTypeDocumentation(sb, agg);
            }
        }

        // Entities
        List<DomainType> entities = ir.domain().typesOfKind(DomainKind.ENTITY);
        if (!entities.isEmpty()) {
            sb.append("## Entities\n\n");
            sb.append("Entities have identity and are accessed through their aggregate root.\n\n");
            for (DomainType entity : entities) {
                generateTypeDocumentation(sb, entity);
            }
        }

        // Value Objects
        List<DomainType> valueObjects = ir.domain().valueObjects();
        if (!valueObjects.isEmpty()) {
            sb.append("## Value Objects\n\n");
            sb.append("Value objects are immutable and defined by their attributes, not identity.\n\n");
            for (DomainType vo : valueObjects) {
                generateTypeDocumentation(sb, vo);
            }
        }

        // Identifiers
        List<DomainType> identifiers = ir.domain().typesOfKind(DomainKind.IDENTIFIER);
        if (!identifiers.isEmpty()) {
            sb.append("## Identifiers\n\n");
            sb.append("Identifier types wrap primitive identity values for type safety.\n\n");
            for (DomainType id : identifiers) {
                generateTypeDocumentation(sb, id);
            }
        }

        // Domain Events
        List<DomainType> events = ir.domain().typesOfKind(DomainKind.DOMAIN_EVENT);
        if (!events.isEmpty()) {
            sb.append("## Domain Events\n\n");
            sb.append("Domain events represent something meaningful that happened in the domain.\n\n");
            for (DomainType event : events) {
                generateTypeDocumentation(sb, event);
            }
        }

        // Domain Services
        List<DomainType> domainServices = ir.domain().typesOfKind(DomainKind.DOMAIN_SERVICE);
        if (!domainServices.isEmpty()) {
            sb.append("## Domain Services\n\n");
            sb.append("Domain services contain domain logic that doesn't belong to entities. ");
            sb.append("They have NO dependencies on infrastructure ports.\n\n");
            for (DomainType service : domainServices) {
                generateTypeDocumentation(sb, service);
            }
        }

        // Application Services
        List<DomainType> appServices = ir.domain().typesOfKind(DomainKind.APPLICATION_SERVICE);
        if (!appServices.isEmpty()) {
            sb.append("## Application Services\n\n");
            sb.append("Application services orchestrate use cases by coordinating domain logic ");
            sb.append("and infrastructure through ports. They have dependencies on DRIVEN ports.\n\n");
            for (DomainType service : appServices) {
                generateTypeDocumentation(sb, service);
            }
        }

        return sb.toString();
    }

    private void generateTableOfContents(StringBuilder sb) {
        sb.append("## Contents\n\n");

        List<DomainType> aggregates = ir.domain().aggregateRoots();
        if (!aggregates.isEmpty()) {
            sb.append("### Aggregate Roots\n");
            for (DomainType agg : aggregates) {
                sb.append("- [")
                        .append(agg.simpleName())
                        .append("](#")
                        .append(toAnchor(agg.simpleName()))
                        .append(")\n");
            }
            sb.append("\n");
        }

        List<DomainType> entities = ir.domain().typesOfKind(DomainKind.ENTITY);
        if (!entities.isEmpty()) {
            sb.append("### Entities\n");
            for (DomainType entity : entities) {
                sb.append("- [")
                        .append(entity.simpleName())
                        .append("](#")
                        .append(toAnchor(entity.simpleName()))
                        .append(")\n");
            }
            sb.append("\n");
        }

        List<DomainType> valueObjects = ir.domain().valueObjects();
        if (!valueObjects.isEmpty()) {
            sb.append("### Value Objects\n");
            for (DomainType vo : valueObjects) {
                sb.append("- [")
                        .append(vo.simpleName())
                        .append("](#")
                        .append(toAnchor(vo.simpleName()))
                        .append(")\n");
            }
            sb.append("\n");
        }

        List<DomainType> identifiers = ir.domain().typesOfKind(DomainKind.IDENTIFIER);
        if (!identifiers.isEmpty()) {
            sb.append("### Identifiers\n");
            for (DomainType id : identifiers) {
                sb.append("- [")
                        .append(id.simpleName())
                        .append("](#")
                        .append(toAnchor(id.simpleName()))
                        .append(")\n");
            }
            sb.append("\n");
        }

        List<DomainType> events = ir.domain().typesOfKind(DomainKind.DOMAIN_EVENT);
        if (!events.isEmpty()) {
            sb.append("### Domain Events\n");
            for (DomainType event : events) {
                sb.append("- [")
                        .append(event.simpleName())
                        .append("](#")
                        .append(toAnchor(event.simpleName()))
                        .append(")\n");
            }
            sb.append("\n");
        }

        List<DomainType> domainServices = ir.domain().typesOfKind(DomainKind.DOMAIN_SERVICE);
        if (!domainServices.isEmpty()) {
            sb.append("### Domain Services\n");
            for (DomainType service : domainServices) {
                sb.append("- [")
                        .append(service.simpleName())
                        .append("](#")
                        .append(toAnchor(service.simpleName()))
                        .append(")\n");
            }
            sb.append("\n");
        }

        List<DomainType> appServices = ir.domain().typesOfKind(DomainKind.APPLICATION_SERVICE);
        if (!appServices.isEmpty()) {
            sb.append("### Application Services\n");
            for (DomainType service : appServices) {
                sb.append("- [")
                        .append(service.simpleName())
                        .append("](#")
                        .append(toAnchor(service.simpleName()))
                        .append(")\n");
            }
            sb.append("\n");
        }

        sb.append("---\n\n");
    }

    private void generateTypeDocumentation(StringBuilder sb, DomainType type) {
        // Type header
        sb.append("### ").append(type.simpleName()).append("\n\n");

        // Metadata table
        sb.append("| Property | Value |\n");
        sb.append("|----------|-------|\n");
        sb.append("| **Kind** | ").append(formatKind(type.kind())).append(" |\n");
        sb.append("| **Package** | `").append(type.packageName()).append("` |\n");
        sb.append("| **Type** | ").append(type.construct()).append(" |\n");
        sb.append("| **Confidence** | ").append(type.confidence()).append(" |\n");
        sb.append("\n");

        // Identity
        if (type.hasIdentity()) {
            Identity id = type.identity().get();
            sb.append("**Identity**\n\n");
            sb.append("| Field | Type | Underlying | Strategy |\n");
            sb.append("|-------|------|------------|----------|\n");
            sb.append("| `")
                    .append(id.fieldName())
                    .append("` | `")
                    .append(id.type().simpleName())
                    .append("` | `")
                    .append(id.unwrappedType().simpleName())
                    .append("` | ")
                    .append(id.strategy())
                    .append(" |\n\n");
        }

        // Properties
        List<DomainProperty> properties = type.properties();
        if (!properties.isEmpty()) {
            sb.append("**Properties**\n\n");
            sb.append("| Name | Type | Cardinality | Notes |\n");
            sb.append("|------|------|-------------|-------|\n");
            for (DomainProperty prop : properties) {
                sb.append("| `")
                        .append(prop.name())
                        .append("` | `")
                        .append(formatPropertyType(prop))
                        .append("` | ")
                        .append(formatCardinality(prop.cardinality()))
                        .append(" | ")
                        .append(formatPropertyNotes(prop))
                        .append(" |\n");
            }
            sb.append("\n");
        }

        // Relations
        List<DomainRelation> relations = type.relations();
        if (!relations.isEmpty()) {
            sb.append("**Relationships**\n\n");
            sb.append("| Target | Kind | Direction |\n");
            sb.append("|--------|------|----------|\n");
            for (DomainRelation rel : relations) {
                sb.append("| `")
                        .append(rel.targetSimpleName())
                        .append("` | ")
                        .append(rel.kind())
                        .append(" | ")
                        .append(rel.isOwning() ? "Owning" : "Inverse")
                        .append(" |\n");
            }
            sb.append("\n");
        }

        // Debug information
        sb.append("<details>\n");
        sb.append("<summary>Debug Information</summary>\n\n");
        sb.append("| Property | Value |\n");
        sb.append("|----------|-------|\n");
        sb.append("| **Qualified Name** | `").append(type.qualifiedName()).append("` |\n");

        // Annotations
        List<String> annotations = type.annotations();
        if (!annotations.isEmpty()) {
            sb.append("| **Annotations** | ");
            for (int i = 0; i < annotations.size(); i++) {
                if (i > 0) sb.append(", ");
                sb.append("`@").append(simplifyType(annotations.get(i))).append("`");
            }
            sb.append(" |\n");
        } else {
            sb.append("| **Annotations** | *none* |\n");
        }

        // Source reference
        if (type.sourceRef() != null && type.sourceRef().isReal()) {
            sb.append("| **Source File** | `").append(type.sourceRef().filePath()).append("` |\n");
            sb.append("| **Line** | ").append(type.sourceRef().lineStart()).append(" |\n");
        }

        sb.append("\n</details>\n\n");

        sb.append("---\n\n");
    }

    private String simplifyType(String qualifiedType) {
        if (qualifiedType == null || qualifiedType.isEmpty()) {
            return "?";
        }
        int lastDot = qualifiedType.lastIndexOf('.');
        return lastDot >= 0 ? qualifiedType.substring(lastDot + 1) : qualifiedType;
    }

    private String formatKind(DomainKind kind) {
        return switch (kind) {
            case AGGREGATE_ROOT -> "Aggregate Root";
            case ENTITY -> "Entity";
            case VALUE_OBJECT -> "Value Object";
            case IDENTIFIER -> "Identifier";
            case DOMAIN_EVENT -> "Domain Event";
            case DOMAIN_SERVICE -> "Domain Service";
            case APPLICATION_SERVICE -> "Application Service";
            case INBOUND_ONLY -> "Inbound Only";
            case OUTBOUND_ONLY -> "Outbound Only";
            case SAGA -> "Saga";
        };
    }

    private String formatPropertyType(DomainProperty prop) {
        if (prop.type().isCollectionLike()) {
            return prop.type().simpleName() + "<" + prop.type().unwrapElement().simpleName() + ">";
        } else if (prop.type().isOptionalLike()) {
            return "Optional<" + prop.type().unwrapElement().simpleName() + ">";
        }
        return prop.type().simpleName();
    }

    private String formatCardinality(Cardinality cardinality) {
        return switch (cardinality) {
            case SINGLE -> "Single";
            case OPTIONAL -> "Optional";
            case COLLECTION -> "Collection";
        };
    }

    private String formatPropertyNotes(DomainProperty prop) {
        StringBuilder notes = new StringBuilder();
        if (prop.isIdentity()) {
            notes.append("Identity");
        }
        if (prop.isEmbedded()) {
            if (!notes.isEmpty()) notes.append(", ");
            notes.append("Embedded");
        }
        if (prop.hasRelation()) {
            if (!notes.isEmpty()) notes.append(", ");
            notes.append("Relation");
        }
        return notes.isEmpty() ? "-" : notes.toString();
    }

    private String toAnchor(String text) {
        return text.toLowerCase().replaceAll("[^a-z0-9]+", "-");
    }
}
