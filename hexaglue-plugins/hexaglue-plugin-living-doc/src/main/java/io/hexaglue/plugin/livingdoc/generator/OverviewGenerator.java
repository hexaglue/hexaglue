/*
 * This Source Code Form is part of the HexaGlue project.
 * Copyright (c) 2026 Scalastic
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 *
 * Commercial licensing options are available for organizations wishing
 * to use HexaGlue under terms different from the MPL 2.0.
 * Contact: info@hexaglue.io
 */

package io.hexaglue.plugin.livingdoc.generator;

import io.hexaglue.plugin.livingdoc.markdown.MarkdownBuilder;
import io.hexaglue.plugin.livingdoc.mermaid.GraphBuilder;
import io.hexaglue.plugin.livingdoc.mermaid.MermaidBuilder;
import io.hexaglue.spi.ir.DomainKind;
import io.hexaglue.spi.ir.DomainType;
import io.hexaglue.spi.ir.IrSnapshot;
import io.hexaglue.spi.ir.Port;
import java.util.List;

/**
 * Generates the architecture overview documentation.
 */
public final class OverviewGenerator {

    private final IrSnapshot ir;

    public OverviewGenerator(IrSnapshot ir) {
        this.ir = ir;
    }

    public String generate(boolean includeDiagram) {
        MarkdownBuilder md = new MarkdownBuilder()
                .h1("Architecture Overview")
                .paragraph("*Generated by HexaGlue Living Documentation Plugin*")
                .horizontalRule();

        // Summary
        generateSummary(md);

        // Quick links
        generateDocumentationLinks(md, includeDiagram);

        // Architecture overview diagram
        if (includeDiagram) {
            generateOverviewDiagram(md);
        }

        // Domain summary
        generateDomainSummary(md);

        // Ports summary
        generatePortsSummary(md);

        return md.build();
    }

    private void generateSummary(MarkdownBuilder md) {
        md.h2("Summary")
                .table("Metric", "Count")
                .row(
                        "Aggregate Roots",
                        String.valueOf(ir.domain().aggregateRoots().size()))
                .row(
                        "Entities",
                        String.valueOf(
                                ir.domain().typesOfKind(DomainKind.ENTITY).size()))
                .row("Value Objects", String.valueOf(ir.domain().valueObjects().size()))
                .row("Driving Ports", String.valueOf(ir.ports().drivingPorts().size()))
                .row("Driven Ports", String.valueOf(ir.ports().drivenPorts().size()))
                .end();
    }

    private void generateDocumentationLinks(MarkdownBuilder md, boolean includeDiagram) {
        md.h2("Documentation")
                .bulletItem("[Domain Model](domain.md) - Aggregates, entities, and value objects")
                .bulletItem("[Ports](ports.md) - Driving and driven ports");
        if (includeDiagram) {
            md.bulletItem("[Diagrams](diagrams.md) - Architecture diagrams");
        }
        md.newline().horizontalRule();
    }

    private void generateOverviewDiagram(MarkdownBuilder md) {
        md.h2("Architecture Diagram");

        GraphBuilder graph = new GraphBuilder(GraphBuilder.Direction.LEFT_TO_RIGHT);

        // External actors
        graph.startSubgraph("External", "External Actors")
                .node("UI", "[UI/API]")
                .endSubgraph();

        // Application layer
        graph.startSubgraph("Application", "Application");

        // Driving Ports subgraph
        graph.startSubgraph("DrivingPorts", "Driving Ports");
        List<Port> driving = ir.ports().drivingPorts();
        if (driving.isEmpty()) {
            graph.node("DP", "[\"(none)\"]");
        } else {
            for (Port port : driving) {
                graph.node(MermaidBuilder.sanitizeId(port.simpleName()), "[\"" + port.simpleName() + "\"]");
            }
        }
        graph.endSubgraph();

        // Domain subgraph
        graph.startSubgraph("Domain", "Domain");
        List<DomainType> aggregates = ir.domain().aggregateRoots();
        if (aggregates.isEmpty()) {
            graph.node("D", "[\"(domain)\"]");
        } else {
            for (DomainType agg : aggregates) {
                graph.node(MermaidBuilder.sanitizeId(agg.simpleName()), "[\"" + agg.simpleName() + "\"]");
            }
        }
        graph.endSubgraph();

        // Driven Ports subgraph
        graph.startSubgraph("DrivenPorts", "Driven Ports");
        List<Port> driven = ir.ports().drivenPorts();
        if (driven.isEmpty()) {
            graph.node("DPOUT", "[\"(none)\"]");
        } else {
            for (Port port : driven) {
                graph.node(MermaidBuilder.sanitizeId(port.simpleName()), "[\"" + port.simpleName() + "\"]");
            }
        }
        graph.endSubgraph();

        graph.endSubgraph(); // End Application

        // Infrastructure
        graph.startSubgraph("Infrastructure", "Infrastructure")
                .node("DB", "[(Database)]")
                .node("EXT", "[External Services]")
                .endSubgraph();

        // Connections
        graph.arrow("UI", "DrivingPorts")
                .arrow("DrivingPorts", "Domain")
                .arrow("Domain", "DrivenPorts")
                .arrow("DrivenPorts", "DB")
                .arrow("DrivenPorts", "EXT");

        md.raw(graph.build());
    }

    private void generateDomainSummary(MarkdownBuilder md) {
        md.h2("Domain Model");

        List<DomainType> aggregates = ir.domain().aggregateRoots();
        if (!aggregates.isEmpty()) {
            md.h3("Aggregate Roots");
            var table = md.table("Name", "Package", "Properties");
            for (DomainType agg : aggregates) {
                table.row(
                        "**" + agg.simpleName() + "**",
                        "`" + agg.packageName() + "`",
                        String.valueOf(agg.properties().size()));
            }
            table.end();
        }

        List<DomainType> valueObjects = ir.domain().valueObjects();
        if (!valueObjects.isEmpty()) {
            md.h3("Value Objects");
            var table = md.table("Name", "Package", "Type");
            for (DomainType vo : valueObjects) {
                table.row(
                        vo.simpleName(),
                        "`" + vo.packageName() + "`",
                        vo.construct().toString());
            }
            table.end();
        }

        md.paragraph("*See [domain.md](domain.md) for complete details.*");
    }

    private void generatePortsSummary(MarkdownBuilder md) {
        md.h2("Ports");

        List<Port> driving = ir.ports().drivingPorts();
        if (!driving.isEmpty()) {
            md.h3("Driving Ports (Primary)");
            var table = md.table("Port", "Kind", "Methods");
            for (Port port : driving) {
                table.row(
                        "**" + port.simpleName() + "**",
                        port.kind().toString(),
                        String.valueOf(port.methods().size()));
            }
            table.end();
        }

        List<Port> driven = ir.ports().drivenPorts();
        if (!driven.isEmpty()) {
            md.h3("Driven Ports (Secondary)");
            var table = md.table("Port", "Kind", "Methods");
            for (Port port : driven) {
                table.row(
                        "**" + port.simpleName() + "**",
                        port.kind().toString(),
                        String.valueOf(port.methods().size()));
            }
            table.end();
        }

        md.paragraph("*See [ports.md](ports.md) for complete details.*");
    }
}
