/*
 * This Source Code Form is part of the HexaGlue project.
 * Copyright (c) 2026 Scalastic
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 *
 * Commercial licensing options are available for organizations wishing
 * to use HexaGlue under terms different from the MPL 2.0.
 * Contact: info@hexaglue.io
 */

package io.hexaglue.maven;

import io.hexaglue.arch.model.audit.AuditSnapshot;
import io.hexaglue.core.engine.Diagnostic;
import io.hexaglue.core.engine.EngineConfig;
import io.hexaglue.core.engine.EngineResult;
import io.hexaglue.core.engine.HexaGlueEngine;
import io.hexaglue.core.plugin.PluginCyclicDependencyException;
import io.hexaglue.core.plugin.PluginDependencyException;
import io.hexaglue.spi.core.ClassificationConfig;
import io.hexaglue.spi.generation.PluginCategory;
import java.io.File;
import java.nio.file.Path;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.MojoFailureException;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.plugins.annotations.ResolutionScope;
import org.apache.maven.project.MavenProject;

/**
 * Executes both HexaGlue code generation and audit in a single step.
 *
 * <p>This mojo combines the functionality of {@code hexaglue:generate} and
 * {@code hexaglue:audit} goals, running both analysis and code generation
 * followed by quality audit. This is useful for CI/CD pipelines where you
 * want to ensure generated code meets quality standards.
 *
 * <p>Usage in pom.xml:
 * <pre>{@code
 * <plugin>
 *     <groupId>io.hexaglue</groupId>
 *     <artifactId>hexaglue-maven-plugin</artifactId>
 *     <version>${hexaglue.version}</version>
 *     <executions>
 *         <execution>
 *             <goals>
 *                 <goal>generate-and-audit</goal>
 *             </goals>
 *         </execution>
 *     </executions>
 *     <configuration>
 *         <basePackage>com.example</basePackage>
 *         <failOnError>true</failOnError>
 *         <errorOnBlocker>true</errorOnBlocker>
 *         <errorOnCritical>false</errorOnCritical>
 *     </configuration>
 * </plugin>
 * }</pre>
 */
@Mojo(
        name = "generate-and-audit",
        defaultPhase = LifecyclePhase.GENERATE_SOURCES,
        requiresDependencyResolution = ResolutionScope.COMPILE,
        threadSafe = true)
public class GenerateAndAuditMojo extends AbstractMojo {

    @Parameter(defaultValue = "${project}", readonly = true, required = true)
    private MavenProject project;

    /**
     * The base package to analyze. Types outside this package are ignored.
     */
    @Parameter(property = "hexaglue.basePackage", required = true)
    private String basePackage;

    /**
     * Skip HexaGlue execution.
     */
    @Parameter(property = "hexaglue.skip", defaultValue = "false")
    private boolean skip;

    /**
     * Output directory for generated sources.
     */
    @Parameter(
            property = "hexaglue.outputDirectory",
            defaultValue = "${project.build.directory}/hexaglue/generated-sources")
    private File outputDirectory;

    /**
     * Whether to fail the build if unclassified types remain.
     *
     * @since 3.0.0
     */
    @Parameter(property = "hexaglue.failOnUnclassified", defaultValue = "false")
    private boolean failOnUnclassified;

    // Audit-specific parameters

    /**
     * Fail the Maven build when audit errors are found.
     * Overrides the YAML {@code failOnError} setting.
     * Default: {@code true}.
     *
     * @since 5.1.0
     */
    @Parameter(property = "hexaglue.failOnError")
    private Boolean failOnError;

    /**
     * Treat BLOCKER violations as audit errors.
     * Overrides the YAML {@code errorOnBlocker} setting.
     * Default: {@code true}.
     *
     * @since 5.1.0
     */
    @Parameter(property = "hexaglue.errorOnBlocker")
    private Boolean errorOnBlocker;

    /**
     * Treat CRITICAL violations as audit errors.
     * Overrides the YAML {@code errorOnCritical} setting.
     * Default: {@code false}.
     *
     * @since 5.1.0
     */
    @Parameter(property = "hexaglue.errorOnCritical")
    private Boolean errorOnCritical;

    /**
     * Output directory for audit reports.
     *
     * <p>Reports are generated by the audit plugin (DddAuditPlugin) in the
     * {@code audit/} subdirectory. This parameter is passed to the plugin
     * via the engine configuration.
     */
    @Parameter(property = "hexaglue.reportDirectory", defaultValue = "${project.build.directory}/hexaglue/reports")
    private File reportDirectory;

    /**
     * Enable tolerant type resolution for projects using annotation processors.
     *
     * <p>When enabled, HexaGlue accepts unresolved types during analysis instead of
     * failing. This is useful for projects using annotation processors (MapStruct,
     * Immutables) whose generated types are not yet on the classpath.
     *
     * @since 6.0.0
     */
    @Parameter(property = "hexaglue.tolerantResolution", defaultValue = "false")
    private boolean tolerantResolution;

    @Override
    public void execute() throws MojoExecutionException, MojoFailureException {
        if (skip) {
            getLog().info("HexaGlue execution skipped");
            return;
        }

        getLog().info("HexaGlue generate-and-audit: " + basePackage);

        // Step 1: Run code generation
        getLog().info("Step 1/2: Running code generation...");
        EngineResult generationResult = runGeneration();

        // Log generation results
        logGenerationResults(generationResult);

        if (!generationResult.isSuccess()) {
            throw new MojoExecutionException("HexaGlue code generation failed with errors");
        }

        // Add generated sources to compilation (skip if already a source root, e.g. src/main/java)
        String outputPath = outputDirectory.getAbsolutePath();
        if (!project.getCompileSourceRoots().contains(outputPath)) {
            if (outputDirectory.exists() || outputDirectory.mkdirs()) {
                project.addCompileSourceRoot(outputPath);
            }
        }

        // Step 2: Run audit
        getLog().info("Step 2/2: Running architecture audit...");
        Optional<AuditSnapshot> auditSnapshot = runAudit();

        if (auditSnapshot.isPresent()) {
            AuditSnapshot snapshot = auditSnapshot.get();

            // Log summary (reports are generated by DddAuditPlugin)
            logAuditSummary(snapshot);

            // Check failure conditions with Maven > YAML > defaults precedence
            Map<String, Map<String, Object>> pluginConfigs =
                    MojoConfigLoader.loadPluginConfigs(project.getBasedir().toPath(), getLog());
            AuditFailureResolver resolver =
                    AuditFailureResolver.resolve(failOnError, errorOnBlocker, errorOnCritical, pluginConfigs);

            long errorCount = resolver.countErrors(snapshot);
            if (resolver.failOnError() && errorCount > 0) {
                throw new MojoFailureException(
                        "Audit failed with " + errorCount + " error-level violations (BLOCKER/CRITICAL)");
            }

            getLog().info("Audit: " + (snapshot.passed() ? "PASSED" : "FAILED"));
        }

        getLog().info("HexaGlue generate-and-audit completed successfully");
    }

    private EngineResult runGeneration() throws MojoExecutionException {
        EngineConfig config = buildGenerationConfig();
        HexaGlueEngine engine = HexaGlueEngine.create();
        try {
            return engine.analyze(config);
        } catch (PluginDependencyException e) {
            throw new MojoExecutionException("Plugin dependency error: " + e.getMessage(), e);
        } catch (PluginCyclicDependencyException e) {
            throw new MojoExecutionException("Cyclic plugin dependency detected: " + e.getMessage(), e);
        }
    }

    private Optional<AuditSnapshot> runAudit() throws MojoExecutionException {
        EngineConfig config = buildAuditConfig();
        HexaGlueEngine engine = HexaGlueEngine.create();

        EngineResult result;
        try {
            result = engine.analyze(config);
        } catch (PluginDependencyException e) {
            throw new MojoExecutionException("Plugin dependency error: " + e.getMessage(), e);
        } catch (PluginCyclicDependencyException e) {
            throw new MojoExecutionException("Cyclic plugin dependency detected: " + e.getMessage(), e);
        }

        // Log diagnostics
        for (Diagnostic diag : result.diagnostics()) {
            switch (diag.severity()) {
                case INFO -> getLog().info(formatDiagnostic(diag));
                case WARNING -> getLog().warn(formatDiagnostic(diag));
                case ERROR -> getLog().error(formatDiagnostic(diag));
            }
        }

        if (!result.isSuccess()) {
            throw new MojoExecutionException("HexaGlue audit analysis failed with errors");
        }

        return extractAuditSnapshot(result);
    }

    private EngineConfig buildGenerationConfig() {
        List<Path> sourceRoots = MojoSourceRootsResolver.resolveSourceRoots(project);

        List<Path> classpath = MojoClasspathBuilder.buildClasspath(project);

        String javaVersionStr = project.getProperties().getProperty("maven.compiler.release", "21");
        int javaVersion;
        try {
            javaVersion = Integer.parseInt(javaVersionStr);
        } catch (NumberFormatException e) {
            javaVersion = 21;
        }

        // Build classification config from hexaglue.yaml (exclusion patterns, explicit classifications)
        ClassificationConfig classificationConfig =
                MojoConfigLoader.loadClassificationConfig(project.getBasedir().toPath(), failOnUnclassified, getLog());

        // Load plugin configs from hexaglue.yaml
        Map<String, Map<String, Object>> pluginConfigs =
                MojoConfigLoader.loadPluginConfigs(project.getBasedir().toPath(), getLog());

        return new EngineConfig(
                sourceRoots,
                classpath,
                javaVersion,
                basePackage,
                project.getName(),
                project.getVersion(),
                outputDirectory.toPath(),
                null,
                pluginConfigs,
                Map.of("hexaglue.projectRoot", project.getBasedir().toPath()),
                classificationConfig,
                Set.of(PluginCategory.GENERATOR), // Only run generator plugins
                false, // Do not include @Generated types during generation
                List.of(), // Mono-module
                tolerantResolution);
    }

    private EngineConfig buildAuditConfig() {
        List<Path> sourceRoots = MojoSourceRootsResolver.resolveSourceRoots(project);

        List<Path> classpath = MojoClasspathBuilder.buildClasspath(project);

        String javaVersionStr = project.getProperties().getProperty("maven.compiler.release", "21");
        int javaVersion;
        try {
            javaVersion = Integer.parseInt(javaVersionStr);
        } catch (NumberFormatException e) {
            javaVersion = 21;
        }

        // Load plugin configs from hexaglue.yaml
        Map<String, Map<String, Object>> pluginConfigs =
                MojoConfigLoader.loadPluginConfigs(project.getBasedir().toPath(), getLog());

        // Build classification config from hexaglue.yaml (exclusion patterns, explicit classifications)
        ClassificationConfig classificationConfig =
                MojoConfigLoader.loadClassificationConfig(project.getBasedir().toPath(), failOnUnclassified, getLog());

        return new EngineConfig(
                sourceRoots,
                classpath,
                javaVersion,
                basePackage,
                project.getName(),
                project.getVersion(),
                null,
                reportDirectory.toPath(), // Audit plugins need output directory for reports
                pluginConfigs,
                Map.of("hexaglue.projectRoot", project.getBasedir().toPath()),
                classificationConfig,
                Set.of(PluginCategory.AUDIT), // Only run audit plugins
                true, // Include @Generated types so audit can see generated adapters
                List.of(), // Mono-module
                tolerantResolution);
    }

    /**
     * Extracts the audit snapshot from the engine result.
     *
     * @param result the engine result containing plugin outputs
     * @return an Optional containing the AuditSnapshot if available, empty otherwise
     */
    private Optional<AuditSnapshot> extractAuditSnapshot(EngineResult result) {
        if (result.pluginResult() == null) {
            getLog().debug("No plugin execution result available");
            return Optional.empty();
        }

        // Try to find audit-snapshot from any audit plugin
        Optional<AuditSnapshot> snapshot = result.pluginResult().findOutput("audit-snapshot", AuditSnapshot.class);

        if (snapshot.isEmpty()) {
            getLog().warn("No audit plugin produced an AuditSnapshot - "
                    + "ensure an audit plugin is on the classpath");
        }

        return snapshot;
    }

    private void logGenerationResults(EngineResult result) {
        for (Diagnostic diag : result.diagnostics()) {
            switch (diag.severity()) {
                case INFO -> getLog().info(formatDiagnostic(diag));
                case WARNING -> getLog().warn(formatDiagnostic(diag));
                case ERROR -> getLog().error(formatDiagnostic(diag));
            }
        }

        getLog().info(String.format(
                "Generation complete: %d types, %d classified, %d ports in %dms",
                result.metrics().totalTypes(),
                result.metrics().classifiedTypes(),
                result.metrics().portsDetected(),
                result.metrics().analysisTime().toMillis()));

        if (result.generatedFileCount() > 0) {
            getLog().info("Generated " + result.generatedFileCount() + " files");
        }
    }

    private void logAuditSummary(AuditSnapshot snapshot) {
        getLog().info("─".repeat(80));
        getLog().info("AUDIT SUMMARY");
        getLog().info("─".repeat(80));
        getLog().info("Total Violations: " + snapshot.violations().size());
        getLog().info("  Errors:   " + snapshot.errorCount());
        getLog().info("  Warnings: " + snapshot.warningCount());
        getLog().info("  Info:     " + snapshot.infos().size());
        getLog().info("Status: " + (snapshot.passed() ? "PASSED" : "FAILED"));
        getLog().info("─".repeat(80));
    }

    private String formatDiagnostic(Diagnostic diag) {
        if (diag.location() != null) {
            return String.format(
                    "[%s] %s (%s:%d)",
                    diag.code(),
                    diag.message(),
                    diag.location().filePath(),
                    diag.location().lineStart());
        }
        return String.format("[%s] %s", diag.code(), diag.message());
    }
}
