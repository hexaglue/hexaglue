/*
 * This Source Code Form is part of the HexaGlue project.
 * Copyright (c) 2026 Scalastic
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 *
 * Commercial licensing options are available for organizations wishing
 * to use HexaGlue under terms different from the MPL 2.0.
 * Contact: info@hexaglue.io
 */

package io.hexaglue.maven;

import java.io.File;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import org.apache.maven.artifact.Artifact;
import org.apache.maven.project.MavenProject;

/**
 * Builds the analysis classpath for Spoon type resolution.
 *
 * <p>Includes the project's compiled output directory ({@code target/classes})
 * when available, in addition to dependency JARs. This enables Spoon to resolve
 * types generated by annotation processors from the classpath when those types
 * are not in the source roots (e.g., generated MapStruct mappers, Immutables
 * implementations).
 *
 * @since 6.0.0
 */
final class MojoClasspathBuilder {

    private MojoClasspathBuilder() {}

    /**
     * Builds the classpath for Spoon analysis from the given Maven project.
     *
     * <p>The returned list includes:
     * <ol>
     *   <li>The project's compiled output directory ({@code target/classes}), if it exists</li>
     *   <li>All resolved dependency artifacts</li>
     * </ol>
     *
     * @param project the Maven project to build the classpath for
     * @return an immutable list of classpath entries
     */
    static List<Path> buildClasspath(MavenProject project) {
        List<Path> classpath = new ArrayList<>();

        String outputDirectory = project.getBuild().getOutputDirectory();
        if (outputDirectory != null) {
            Path outputDir = Path.of(outputDirectory);
            if (Files.isDirectory(outputDir)) {
                classpath.add(outputDir);
            }
        }

        project.getArtifacts().stream()
                .map(Artifact::getFile)
                .filter(Objects::nonNull)
                .map(File::toPath)
                .forEach(classpath::add);

        return List.copyOf(classpath);
    }
}
