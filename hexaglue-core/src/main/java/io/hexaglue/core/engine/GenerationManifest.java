/*
 * This Source Code Form is part of the HexaGlue project.
 * Copyright (c) 2026 Scalastic
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 *
 * Commercial licensing options are available for organizations wishing
 * to use HexaGlue under terms different from the MPL 2.0.
 * Contact: info@hexaglue.io
 */

package io.hexaglue.core.engine;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.Instant;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Tracks files generated by HexaGlue to support stale file detection and overwrite protection.
 *
 * <p>Two manifest instances are typically used in a build:
 * <ul>
 *   <li><strong>Ephemeral</strong> ({@code target/hexaglue/manifest.json}): tracks files
 *       in {@code target/}. Recreated each build; deleted by {@code mvn clean}.</li>
 *   <li><strong>Persistent</strong> ({@code .hexaglue/manifest.json} at reactor root): tracks
 *       files written to {@code src/} directories. Survives {@code mvn clean} and can be
 *       version-controlled.</li>
 * </ul>
 *
 * <p>After each generation run, the manifest is compared with the previous one to detect
 * stale files (files that were generated previously but not regenerated).</p>
 *
 * <p>Each file entry optionally stores a SHA-256 checksum. When present, the checksum
 * enables the {@link OverwritePolicy#IF_UNCHANGED} strategy to detect manual edits.</p>
 *
 * @since 5.0.0
 */
public final class GenerationManifest {

    private final Path manifestPath;
    private final Map<String, Map<String, String>> filesByPlugin;
    private final Instant generatedAt;

    /**
     * Creates a new empty manifest.
     *
     * @param manifestPath the file path where this manifest will be stored
     */
    public GenerationManifest(Path manifestPath) {
        this.manifestPath = Objects.requireNonNull(manifestPath, "manifestPath must not be null");
        this.filesByPlugin = new LinkedHashMap<>();
        this.generatedAt = Instant.now();
    }

    /**
     * Records a generated file for a specific plugin without a checksum.
     *
     * @param pluginId the plugin that generated the file
     * @param filePath the path to the generated file (relative or absolute)
     */
    public void recordFile(String pluginId, Path filePath) {
        recordFile(pluginId, filePath, null);
    }

    /**
     * Records a generated file for a specific plugin with an optional SHA-256 checksum.
     *
     * @param pluginId the plugin that generated the file
     * @param filePath the path to the generated file (relative or absolute)
     * @param checksum the SHA-256 checksum of the file content (may be null)
     * @since 5.0.0
     */
    public void recordFile(String pluginId, Path filePath, String checksum) {
        Objects.requireNonNull(pluginId, "pluginId must not be null");
        Objects.requireNonNull(filePath, "filePath must not be null");
        filesByPlugin.computeIfAbsent(pluginId, k -> new LinkedHashMap<>()).put(filePath.toString(), checksum);
    }

    /**
     * Returns the checksum for a file path, if available.
     *
     * @param filePath the file path string to look up
     * @return the checksum if recorded, or empty if not found or no checksum stored
     * @since 5.0.0
     */
    public Optional<String> checksumFor(String filePath) {
        for (Map<String, String> files : filesByPlugin.values()) {
            String checksum = files.get(filePath);
            if (checksum != null) {
                return Optional.of(checksum);
            }
        }
        return Optional.empty();
    }

    /**
     * Returns all recorded file paths across all plugins.
     *
     * @return an unmodifiable set of file path strings
     */
    public Set<String> allFiles() {
        return filesByPlugin.values().stream()
                .flatMap(m -> m.keySet().stream())
                .collect(Collectors.toUnmodifiableSet());
    }

    /**
     * Returns the file paths recorded for a specific plugin.
     *
     * @param pluginId the plugin identifier
     * @return an unmodifiable set of file paths, or empty set if plugin not found
     */
    public Set<String> filesForPlugin(String pluginId) {
        Map<String, String> files = filesByPlugin.get(pluginId);
        return files != null ? Set.copyOf(files.keySet()) : Set.of();
    }

    /**
     * Computes files that are in the {@code previous} manifest but not in this one.
     *
     * <p>These are "stale" files that were generated in a prior build but were not
     * regenerated in the current build, typically because the source type was removed
     * or its classification changed.</p>
     *
     * @param previous the manifest from the previous build (may be null)
     * @return the set of stale file paths
     */
    public Set<String> computeStaleFiles(GenerationManifest previous) {
        if (previous == null) {
            return Set.of();
        }
        Set<String> currentFiles = allFiles();
        return previous.allFiles().stream()
                .filter(f -> !currentFiles.contains(f))
                .collect(Collectors.toUnmodifiableSet());
    }

    /**
     * Saves this manifest to its configured file path as a simple text format.
     *
     * <p>Format: one file path per line, grouped by plugin with {@code # plugin: <id>} headers.
     * Each file entry may include a checksum separated by a pipe character:
     * {@code path|sha256:hex}.</p>
     *
     * @throws IOException if writing fails
     */
    public void save() throws IOException {
        Files.createDirectories(manifestPath.getParent());
        StringBuilder sb = new StringBuilder();
        sb.append("# HexaGlue Generation Manifest\n");
        sb.append("# Generated at: ").append(generatedAt).append("\n");
        sb.append("#\n");
        for (Map.Entry<String, Map<String, String>> entry : filesByPlugin.entrySet()) {
            sb.append("# plugin: ").append(entry.getKey()).append("\n");
            for (Map.Entry<String, String> fileEntry : entry.getValue().entrySet()) {
                sb.append(fileEntry.getKey());
                if (fileEntry.getValue() != null) {
                    sb.append("|").append(fileEntry.getValue());
                }
                sb.append("\n");
            }
        }
        Files.writeString(manifestPath, sb.toString());
    }

    /**
     * Loads a manifest from a file.
     *
     * <p>Supports both the legacy format (path-only, one per line) and the new format
     * with checksums ({@code path|sha256:hex}).</p>
     *
     * @param manifestPath the path to the manifest file
     * @return the loaded manifest, or a new empty manifest if the file does not exist
     * @throws IOException if reading fails (other than file-not-found)
     */
    public static GenerationManifest load(Path manifestPath) throws IOException {
        GenerationManifest manifest = new GenerationManifest(manifestPath);
        if (!Files.exists(manifestPath)) {
            return manifest;
        }
        List<String> lines = Files.readAllLines(manifestPath);
        String currentPlugin = "unknown";
        for (String line : lines) {
            if (line.startsWith("# plugin: ")) {
                currentPlugin = line.substring("# plugin: ".length()).trim();
            } else if (!line.startsWith("#") && !line.isBlank()) {
                String trimmed = line.trim();
                int pipe = trimmed.indexOf('|');
                if (pipe >= 0) {
                    String path = trimmed.substring(0, pipe);
                    String checksum = trimmed.substring(pipe + 1);
                    manifest.recordFile(currentPlugin, Path.of(path), checksum);
                } else {
                    manifest.recordFile(currentPlugin, Path.of(trimmed));
                }
            }
        }
        return manifest;
    }

    /**
     * Returns the path where this manifest is stored.
     *
     * @return the manifest file path
     */
    public Path manifestPath() {
        return manifestPath;
    }

    /**
     * Returns the number of tracked files across all plugins.
     *
     * @return the total file count
     */
    public int fileCount() {
        return filesByPlugin.values().stream().mapToInt(Map::size).sum();
    }
}
